<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>DocuFlow Scanner</title>
    <meta name="description" content="Instant document scanner and organizer.">

    <link rel="preconnect" href="https://cdn.tailwindcss.com" crossorigin>
    <link rel="preconnect" href="https://docs.opencv.org" crossorigin>
    <link rel="preconnect" href="https://cdn.jsdelivr.net" crossorigin>
    <link rel="preconnect" href="https://cdnjs.cloudflare.com" crossorigin>
    <link rel="preconnect" href="https://unpkg.com" crossorigin>
    <link rel="preconnect" href="https://www.gstatic.com" crossorigin>

    <script src="https://cdn.tailwindcss.com"></script>
    <script>
        tailwind.config = {
            theme: { extend: { colors: { gray: { 900: '#111827', 800: '#1f2937' } } } }
        }
    </script>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.11.174/pdf.min.js"></script>
    <script>
        // Set the worker source immediately
        window.pdfjsLib.GlobalWorkerOptions.workerSrc = 'https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.11.174/pdf.worker.min.js';
    </script>

    <style>
        /* Hardware Acceleration for smoother animations */
        .hardware-accel { transform: translate3d(0,0,0); backface-visibility: hidden; }
        
        .scanner-overlay {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            z-index: 20; pointer-events: none;
            border-style: solid; border-color: rgba(0, 0, 0, 0.7); border-width: 10vh 10vw; 
            box-sizing: border-box; transition: border-width 0.3s ease;
        }
        .scan-line {
            position: absolute; width: 100%; height: 2px;
            background: #00ff9d; box-shadow: 0 0 10px #00ff9d;
            top: 0; animation: scanMove 2s infinite linear; display: none;
        }
        @keyframes scanMove {
            0% { top: 0; opacity: 0; }
            10% { opacity: 1; }
            90% { opacity: 1; }
            100% { top: 100%; opacity: 0; }
        }
        .scanning .scan-line { display: block; }
        body { -webkit-tap-highlight-color: transparent; overscroll-behavior-y: none; }
        ::-webkit-scrollbar { display: none; }
        .loader {
            border: 3px solid #f3f3f3; border-radius: 50%; border-top: 3px solid #10b981;
            width: 20px; height: 20px; animation: spin 1s linear infinite;
        }
        @keyframes spin { 0% { transform: rotate(0deg); } 100% { transform: rotate(360deg); } }
    </style>
</head>
<body class="bg-gray-900 text-white h-screen w-screen overflow-hidden font-sans antialiased selection:bg-emerald-500/30">

    <input type="file" id="doc-upload-input" accept="image/*,application/pdf" class="hidden" onchange="handleDocUpload(this)">

    <header class="fixed top-0 w-full z-50 bg-gray-900/90 backdrop-blur border-b border-gray-800 p-4 flex justify-between items-center h-16 hardware-accel">
        <div class="flex items-center gap-2">
            <i data-lucide="layers" class="text-emerald-400"></i>
            <h1 class="font-bold text-lg tracking-wide">DocuFlow</h1>
        </div>
        <div class="flex gap-2">
            <input type="file" id="archive-upload" accept=".cbor" class="hidden" onchange="handleArchiveUpload(this)">
            <button onclick="document.getElementById('archive-upload').click()" class="text-xs bg-gray-800 hover:bg-gray-700 px-3 py-1.5 rounded-full border border-gray-700 text-gray-400 flex items-center gap-1 active:scale-95 transition-transform">
                <i data-lucide="archive-restore" class="w-3 h-3"></i> Archive
            </button>
        </div>
    </header>

    <main id="view-jobs" class="pt-20 pb-24 px-4 h-full overflow-y-auto relative hardware-accel">
        <div class="bg-gray-800/50 rounded-lg p-3 mb-6 border border-gray-700">
            <div class="flex justify-between items-end mb-2">
                <span class="text-xs text-gray-400 font-medium">Storage Usage</span>
                <span id="storage-text" class="text-xs font-mono text-emerald-400">Calculating...</span>
            </div>
            <div class="h-2 w-full bg-gray-700 rounded-full overflow-hidden">
                <div id="storage-bar" class="h-full bg-emerald-500 w-0 transition-all duration-500"></div>
            </div>
            <div id="archive-alert" class="hidden mt-3 pt-3 border-t border-gray-700/50 flex items-center justify-between">
                <span class="text-xs text-yellow-400 flex items-center gap-1">
                    <i data-lucide="hard-drive" class="w-3 h-3"></i> Cleanup Recommended
                </span>
                <button onclick="archiveClosedJobs()" class="text-xs bg-yellow-900/30 text-yellow-300 px-3 py-1.5 rounded border border-yellow-900/50 hover:bg-yellow-900/50 transition-colors">
                    Archive Completed
                </button>
            </div>
        </div>

        <div class="flex justify-between items-end mb-4">
            <h2 class="text-xl font-semibold text-gray-200">Job List</h2>
            <span id="connection-status" class="text-[10px] text-gray-500 flex items-center gap-1">
                <div class="w-2 h-2 rounded-full bg-red-500"></div> Offline
            </span>
        </div>

        <div class="mb-4 relative">
            <input type="text" id="job-search" placeholder="Search Client, ID, or Content..." 
                   class="w-full bg-gray-800 text-white border border-gray-700 rounded-lg py-3 pl-10 pr-4 focus:border-emerald-500 outline-none text-sm placeholder-gray-500 transition-colors"
                   onkeyup="handleSearch()">
            <i data-lucide="search" class="absolute left-3 top-3.5 text-gray-500 w-4 h-4"></i>
        </div>
        
        <div class="space-y-4 pb-20" id="job-container">
            <div class="animate-pulse space-y-3">
                <div class="h-20 bg-gray-800 rounded-xl border border-gray-700"></div>
                <div class="h-20 bg-gray-800 rounded-xl border border-gray-700"></div>
            </div>
        </div>

        <button onclick="openNewJobModal()" class="fixed bottom-8 right-8 w-14 h-14 bg-emerald-500 rounded-full flex items-center justify-center shadow-lg shadow-emerald-500/20 active:scale-90 transition-transform z-30">
            <i data-lucide="plus" class="text-white w-8 h-8"></i>
        </button>
    </main>

    <div id="view-job-details" class="fixed inset-0 bg-gray-900 z-40 hidden flex flex-col pt-16 hardware-accel">
        <div class="h-16 flex items-center gap-4 px-4 border-b border-gray-800 bg-gray-900/50 backdrop-blur shrink-0">
            <button onclick="closeJobDetails()" class="p-2 -ml-2 text-gray-400 hover:text-white">
                <i data-lucide="arrow-left"></i>
            </button>
            <div class="flex-1">
                <h2 id="detail-client" class="font-bold text-lg leading-tight text-white">Client Name</h2>
                <div class="flex items-center gap-2">
                    <span id="detail-id" class="text-xs font-mono text-emerald-400">#ID</span>
                    <span id="detail-status" class="text-[10px] px-1.5 py-0.5 rounded font-bold uppercase tracking-wider">Status</span>
                    <span id="detail-archive-badge" class="hidden text-[10px] px-1.5 py-0.5 rounded bg-purple-900/50 text-purple-300 border border-purple-800">ARCHIVED</span>
                </div>
            </div>
            <button onclick="downloadJobBundle()" class="p-2 text-red-400 hover:text-white bg-red-900/20 rounded-full border border-red-900/50 active:scale-95 transition-transform" title="Download All as PDF">
                <i data-lucide="file-stack" class="w-5 h-5"></i>
            </button>
        </div>
        
        <div class="flex-1 overflow-y-auto p-4 space-y-3" id="document-list"></div>

        <div id="empty-docs" class="hidden absolute inset-0 flex flex-col items-center justify-center text-gray-600 pointer-events-none pt-20">
            <i data-lucide="folder-open" class="w-16 h-16 mb-2 opacity-20"></i>
            <p class="text-sm">No documents yet</p>
        </div>

        <button id="scan-fab" onclick="openAddMenu()" class="absolute bottom-8 right-8 w-14 h-14 bg-emerald-500 rounded-full flex items-center justify-center shadow-lg shadow-emerald-500/20 active:scale-90 transition-transform z-50">
            <i data-lucide="plus" class="text-white w-6 h-6"></i>
        </button>
    </div>

    <div id="add-menu-modal" class="fixed inset-0 z-[80] hidden flex items-end sm:items-center justify-center bg-black/80 backdrop-blur-sm px-4 pb-4 sm:pb-0 transition-opacity duration-200">
        <div class="bg-gray-800 p-6 rounded-2xl w-full max-w-sm border border-gray-700 shadow-2xl flex flex-col gap-3">
            <h3 class="text-lg font-bold text-white mb-2 text-center">Add Document</h3>
            <button onclick="openScannerFromMenu()" class="flex items-center gap-4 p-4 bg-gray-700/50 hover:bg-gray-700 rounded-xl border border-gray-600 transition-colors group">
                <div class="w-12 h-12 rounded-full bg-emerald-900/30 flex items-center justify-center text-emerald-400 group-hover:bg-emerald-500 group-hover:text-white transition-colors"><i data-lucide="camera" class="w-6 h-6"></i></div>
                <div class="text-left"><p class="font-bold text-gray-200">Scan with Camera</p><p class="text-xs text-gray-400">Capture and auto-crop</p></div>
            </button>
            <button onclick="triggerDocUploadFromMenu()" class="flex items-center gap-4 p-4 bg-gray-700/50 hover:bg-gray-700 rounded-xl border border-gray-600 transition-colors group">
                <div class="w-12 h-12 rounded-full bg-blue-900/30 flex items-center justify-center text-blue-400 group-hover:bg-blue-500 group-hover:text-white transition-colors"><i data-lucide="image" class="w-6 h-6"></i></div>
                <div class="text-left"><p class="font-bold text-gray-200">Upload Image or PDF</p><p class="text-xs text-gray-400">From gallery or file system</p></div>
            </button>
            <button onclick="handlePasteClick()" class="flex items-center gap-4 p-4 bg-gray-700/50 hover:bg-gray-700 rounded-xl border border-gray-600 transition-colors group">
                <div class="w-12 h-12 rounded-full bg-purple-900/30 flex items-center justify-center text-purple-400 group-hover:bg-purple-500 group-hover:text-white transition-colors"><i data-lucide="clipboard" class="w-6 h-6"></i></div>
                <div class="text-left"><p class="font-bold text-gray-200">Paste from Clipboard</p><p class="text-xs text-gray-400">Paste copied image (Ctrl+V)</p></div>
            </button>
            <button onclick="closeAddMenu()" class="mt-2 py-3 text-gray-400 font-medium hover:text-white rounded-lg hover:bg-gray-700/50 transition-colors">Cancel</button>
        </div>
    </div>

    <div id="download-modal" class="fixed inset-0 z-[90] hidden flex items-center justify-center bg-black/80 backdrop-blur-sm px-2 md:px-4 opacity-0 transition-opacity duration-200">
        
        <div class="bg-gray-900 md:bg-gray-800 rounded-2xl w-full max-w-7xl border border-gray-700 shadow-2xl relative overflow-hidden flex flex-col md:flex-row h-[85vh] md:h-[95vh]">
            
            <div class="absolute inset-0 md:relative md:inset-auto md:w-[70%] bg-black/50 md:bg-gray-900 flex items-center justify-center p-0 md:p-4 z-0">
                <div class="loader absolute text-emerald-500" id="preview-loader"></div>
                <img id="download-preview-img" class="w-full h-full object-contain opacity-0 transition-opacity duration-300" onload="this.classList.remove('opacity-0'); document.getElementById('preview-loader').classList.add('hidden')">
            </div>

            <div class="absolute bottom-0 left-0 right-0 z-10 p-5 bg-gray-900/95 backdrop-blur-xl border-t border-gray-700 rounded-t-2xl md:relative md:inset-auto md:w-[30%] md:bg-gray-800 md:border-t-0 md:border-l md:rounded-none md:flex md:flex-col">
                
                <div class="flex justify-between items-start mb-4">
                    <h3 class="text-lg md:text-xl font-bold text-white">Export to PDF</h3>
                    <button onclick="closeDownloadModal()" class="text-gray-400 hover:text-white"><i data-lucide="x" class="w-6 h-6"></i></button>
                </div>
                
                <p class="hidden md:block text-sm text-gray-400 mb-6">Review the document and give it a specific name before exporting.</p>

                <div class="space-y-4 md:mt-auto">
                    <div>
                        <label class="block text-xs font-semibold text-gray-500 uppercase tracking-wider mb-1.5">Filename</label>
                        <div class="relative">
                            <input type="text" id="pdf-filename" class="w-full bg-gray-800 md:bg-gray-900 text-white border border-gray-600 rounded-xl p-3 pr-12 focus:border-emerald-500 outline-none font-mono text-sm" placeholder="e.g. PO_12345">
                            <span class="absolute right-4 top-3.5 text-gray-500 text-sm">.pdf</span>
                        </div>
                    </div>

                    <div class="flex gap-3 pt-2">
                        <button onclick="closeDownloadModal()" class="flex-1 py-3 text-gray-400 font-medium hover:text-white rounded-xl hover:bg-gray-700/50 transition-colors">Cancel</button>
                        <button onclick="executePDFDownload()" class="flex-1 py-3 bg-emerald-500 text-white font-bold rounded-xl shadow-lg shadow-emerald-500/20 active:scale-95 transition-transform flex justify-center items-center gap-2">
                            <span>Download</span> <i data-lucide="download" class="w-4 h-4"></i>
                        </button>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <div id="view-scanner" class="fixed inset-0 bg-black z-[60] hidden flex flex-col">
        <div class="relative flex-1 bg-black overflow-hidden flex items-center justify-center">
            <video id="video" class="absolute min-w-full min-h-full object-cover" playsinline autoplay muted></video>
            <canvas id="highlight-canvas" class="absolute top-0 left-0 w-full h-full pointer-events-none"></canvas>
            <div class="absolute inset-0 z-10 flex items-center justify-center pointer-events-none">
                <div class="w-[85%] h-[70%] border-2 border-white/30 rounded-lg relative shadow-[0_0_0_9999px_rgba(0,0,0,0.7)]">
                    <div class="absolute -top-1 -left-1 w-6 h-6 border-t-4 border-l-4 border-emerald-400 rounded-tl-lg"></div>
                    <div class="absolute -top-1 -right-1 w-6 h-6 border-t-4 border-r-4 border-emerald-400 rounded-tr-lg"></div>
                    <div class="absolute -bottom-1 -left-1 w-6 h-6 border-b-4 border-l-4 border-emerald-400 rounded-bl-lg"></div>
                    <div class="absolute -bottom-1 -right-1 w-6 h-6 border-b-4 border-r-4 border-emerald-400 rounded-br-lg"></div>
                    <div class="scan-line"></div>
                </div>
            </div>
            <div id="scan-feedback" class="absolute top-10 bg-black/60 px-4 py-2 rounded-full text-sm font-medium backdrop-blur hidden flex-col items-center">
                <span>Hold steady...</span>
            </div>
        </div>
        <div class="h-32 bg-gray-900 flex items-center justify-around px-8 z-20">
            <button onclick="closeScanner()" class="p-4 rounded-full bg-gray-800 text-gray-400 hover:text-white transition-colors"><i data-lucide="x"></i></button>
            <button onclick="captureDoc()" class="w-16 h-16 rounded-full border-4 border-white flex items-center justify-center bg-transparent active:scale-90 transition-transform"><div class="w-12 h-12 bg-white rounded-full"></div></button>
            <button onclick="triggerDocUpload()" class="p-4 rounded-full bg-gray-800 text-emerald-400 hover:bg-gray-700 transition-colors"><i data-lucide="image"></i></button>
        </div>
    </div>

    <div id="view-editor" class="fixed inset-0 bg-gray-900 z-[70] hidden flex flex-col">
        <div class="h-16 flex items-center justify-between px-4 border-b border-gray-700 bg-gray-900/95 backdrop-blur shrink-0 z-10">
            <button onclick="cancelEdit()" class="text-gray-400 hover:text-white px-2">Cancel</button>
            <div class="flex items-center gap-2">
                <button onclick="handleAddPage()" class="flex items-center gap-1 bg-gray-800 hover:bg-gray-700 text-blue-400 px-3 py-1.5 rounded-lg border border-blue-500/30 text-xs font-bold active:scale-95 transition-all">
                    <i data-lucide="plus-square" class="w-4 h-4"></i>
                    <span>Page</span>
                </button>
                <button id="editor-save-btn" onclick="openSaveModal()" class="bg-emerald-600 hover:bg-emerald-500 text-white px-4 py-1.5 rounded-lg text-xs font-bold shadow-lg shadow-emerald-900/20 active:scale-95 transition-all">
                    Save
                </button>
            </div>
        </div>
        <div class="flex-1 bg-gray-800 relative overflow-hidden flex items-center justify-center p-6 bg-[radial-gradient(#374151_1px,transparent_1px)] [background-size:16px_16px]">
            <div id="canvas-wrapper" class="shadow-2xl border border-gray-600/50"><canvas id="fabric-canvas"></canvas></div>
        </div>
        <div id="editor-toolbar" class="bg-gray-900 border-t border-gray-700 pb-safe-area">
            <input type="file" id="stamp-input" accept="image/*" class="hidden" onchange="processStampUpload(this)">
            <div class="h-24 flex items-center justify-around px-4">
                <button onclick="rotateDoc('left')" class="flex flex-col items-center gap-1.5 group w-14">
                    <div class="w-10 h-10 rounded-full bg-gray-800 border border-gray-700 flex items-center justify-center group-active:scale-90 transition-all text-gray-300 group-hover:text-white group-hover:border-gray-500"><i data-lucide="rotate-ccw" class="w-5 h-5"></i></div>
                    <span class="text-[10px] text-gray-400 font-medium">Left</span>
                </button>
                <button onclick="cycleFilter()" class="flex flex-col items-center gap-1.5 group w-14">
                    <div class="w-10 h-10 rounded-full bg-indigo-600/20 border border-indigo-500/50 flex items-center justify-center group-active:scale-90 transition-all shadow-[0_0_15px_rgba(79,70,229,0.2)]"><i data-lucide="wand-2" class="w-5 h-5 text-indigo-400"></i></div>
                    <span id="filter-label" class="text-[10px] text-indigo-300 font-medium">Original</span>
                </button>
                <button onclick="rotateDoc('right')" class="flex flex-col items-center gap-1.5 group w-14">
                    <div class="w-10 h-10 rounded-full bg-gray-800 border border-gray-700 flex items-center justify-center group-active:scale-90 transition-all text-gray-300 group-hover:text-white group-hover:border-gray-500"><i data-lucide="rotate-cw" class="w-5 h-5"></i></div>
                    <span class="text-[10px] text-gray-400 font-medium">Right</span>
                </button>
                
                <div class="h-8 w-px bg-gray-700 mx-1"></div>

                <div id="stamp-options-menu" class="hidden absolute bottom-24 left-1/2 -translate-x-1/2 bg-gray-800 border border-gray-700 rounded-xl shadow-xl p-2 flex flex-col gap-2 w-48 z-50">
                    <button onclick="triggerStampInput(); toggleStampMenu()" class="flex items-center gap-3 px-4 py-3 text-sm text-gray-200 hover:bg-gray-700 rounded-lg transition-colors text-left">
                        <i data-lucide="image-plus" class="w-4 h-4 text-blue-400"></i>
                        <span>Upload Image</span>
                    </button>
                    <button onclick="handlePasteButton(); toggleStampMenu()" class="flex items-center gap-3 px-4 py-3 text-sm text-gray-200 hover:bg-gray-700 rounded-lg transition-colors text-left">
                        <i data-lucide="clipboard-paste" class="w-4 h-4 text-emerald-400"></i>
                        <span>Paste (Ctrl+V)</span>
                    </button>
                    <div class="absolute -bottom-2 left-1/2 -translate-x-1/2 w-4 h-4 bg-gray-800 border-r border-b border-gray-700 rotate-45"></div>
                </div>
                
                <button onclick="toggleStampMenu()" class="relative flex flex-col items-center gap-1.5 group w-14">
                    <div class="w-10 h-10 rounded-full bg-blue-900/30 border border-blue-500/50 flex items-center justify-center group-active:scale-90 transition-all text-blue-400">
                        <i data-lucide="stamp" class="w-5 h-5"></i>
                    </div>
                    <span class="text-[10px] text-blue-400 font-medium">Stamp</span>
                </button>

                <button onclick="addTextToCanvas()" class="flex flex-col items-center gap-1.5 group w-14">
                    <div class="w-10 h-10 rounded-full bg-red-900/30 border border-red-500/50 flex items-center justify-center group-active:scale-90 transition-all text-red-400"><i data-lucide="type" class="w-5 h-5"></i></div>
                    <span class="text-[10px] text-red-400 font-medium">Text</span>
                </button>
            </div>
        </div>
        <div id="stamp-slider-container" class="hidden absolute bottom-36 left-1/2 -translate-x-1/2 w-72 bg-gray-900/95 backdrop-blur-xl p-4 rounded-2xl border border-gray-700/50 shadow-2xl z-[75] flex flex-col gap-3 transition-all duration-200">
            <div class="flex justify-between items-center border-b border-gray-700/50 pb-2">
                <span class="text-xs font-bold text-gray-200 uppercase tracking-wider flex items-center gap-2">
                    <i data-lucide="sliders-horizontal" class="w-3 h-3 text-emerald-400"></i>
                    Stamp Cleanup
                </span>
                <span id="slider-value-display" class="text-[10px] font-mono text-emerald-400 bg-emerald-900/30 px-1.5 py-0.5 rounded border border-emerald-900/50">150</span>
            </div>
        
            <div class="relative w-full py-1">
                <input type="range" id="stamp-threshold" min="1" max="255" value="150" 
                       class="w-full h-1.5 bg-gray-700 rounded-full appearance-none cursor-pointer accent-emerald-500 hover:accent-emerald-400 transition-all focus:outline-none focus:ring-2 focus:ring-emerald-500/30"
                       oninput="updateStampThreshold(this.value); document.getElementById('slider-value-display').innerText = this.value">
            </div>
        
            <div class="flex justify-between text-[10px] font-medium text-gray-500 uppercase tracking-tight">
                <span class="flex items-center gap-1"><i data-lucide="minus" class="w-3 h-3"></i> Keep Detail</span>
                <span class="flex items-center gap-1">Remove Background <i data-lucide="plus" class="w-3 h-3"></i></span>
            </div>
        </div>
    </div>

    <div id="new-job-modal" class="fixed inset-0 z-[80] hidden flex items-center justify-center bg-black/80 backdrop-blur-sm px-4">
        <div class="bg-gray-800 p-6 rounded-2xl w-full max-w-sm border border-gray-700 shadow-2xl">
            <h3 class="text-lg font-bold text-white mb-4">Create New Job</h3>
            <label class="block text-xs font-semibold text-gray-500 uppercase tracking-wider mb-2">Client / Job Title</label>
            <input type="text" id="new-job-title" placeholder="e.g. Site Visit - Building A" class="w-full bg-gray-900 text-white border border-gray-700 rounded-lg p-3 mb-6 focus:border-emerald-500 outline-none">
            <div class="flex gap-3">
                <button onclick="closeNewJobModal()" class="flex-1 py-3 text-gray-400 font-medium hover:text-white rounded-lg hover:bg-gray-700/50 transition-colors">Cancel</button>
                <button onclick="confirmNewJob()" class="flex-1 py-3 bg-emerald-500 text-white font-bold rounded-lg shadow-lg shadow-emerald-500/20 active:scale-95 transition-transform">Create</button>
            </div>
        </div>
    </div>

    <div id="save-modal" class="fixed inset-0 z-[80] hidden flex items-center justify-center bg-black/80 backdrop-blur-sm px-4">
        <div class="bg-gray-800 p-6 rounded-2xl w-full max-w-sm border border-gray-700 shadow-2xl">
            <h3 class="text-lg font-bold text-white mb-1">Save Document</h3>
            <p class="text-xs text-gray-400 mb-6">Select the document category.</p>
            <label class="block text-xs font-semibold text-gray-500 uppercase tracking-wider mb-2">Category</label>
            <div class="relative mb-8">
                <select id="doc-type-select" class="w-full bg-gray-900 text-white border border-gray-700 rounded-lg p-3 pr-10 focus:border-emerald-500 outline-none appearance-none">
                    <option value="Quotation">Quotation</option>
                    <option value="Purchase Request">Purchase Request</option>
                    <option value="Purchase Order">Purchase Order </option>
                    <option value="Service Report">Service Report</option>
                    <option value="Delivery Order">Delivery Order ðŸŒŸ</option>
                    <option value="Invoice">Invoice</option>
                    <option value="Permit to Work">Permit to Work</option>
                    <option value="Other">Other</option>
                </select>
                <i data-lucide="chevron-down" class="absolute right-3 top-3.5 text-gray-400 w-5 h-5 pointer-events-none"></i>
            </div>
            <div class="flex items-center gap-3 mb-4 bg-gray-900/50 p-3 rounded-lg border border-gray-700 cursor-pointer" onclick="document.getElementById('doc-signed-check').click()">
                <input type="checkbox" id="doc-signed-check" class="w-5 h-5 text-emerald-500 rounded focus:ring-emerald-500 border-gray-600 bg-gray-800 accent-emerald-500">
                <label for="doc-signed-check" class="text-sm text-gray-300 font-medium cursor-pointer select-none">Document is Signed & Stamped</label>
            </div>
            <div class="flex gap-3">
                <button id="btn-cancel-save" onclick="closeSaveModal()" class="flex-1 py-3 text-gray-400 font-medium hover:text-white rounded-lg hover:bg-gray-700/50 transition-colors">Cancel</button>
                <button id="btn-confirm-save" onclick="confirmSave()" class="flex-1 py-3 bg-emerald-500 text-white font-bold rounded-lg shadow-lg shadow-emerald-500/20 active:scale-95 transition-transform flex justify-center items-center gap-2"><span>Save</span><i data-lucide="check" class="w-4 h-4"></i></button>
            </div>
        </div>
    </div>

    <div id="delete-modal" class="fixed inset-0 z-[100] hidden flex items-center justify-center bg-black/90 backdrop-blur-sm px-4 opacity-0 transition-opacity duration-200">
        <div class="bg-gray-800 p-6 rounded-2xl w-full max-w-xs border border-red-900/50 shadow-2xl flex flex-col gap-4">
            <div class="flex flex-col items-center text-center">
                <div class="w-12 h-12 rounded-full bg-red-900/30 flex items-center justify-center mb-3">
                    <i data-lucide="trash-2" class="w-6 h-6 text-red-500"></i>
                </div>
                <h3 class="text-lg font-bold text-white">Delete Document?</h3>
                <p class="text-xs text-gray-400 mt-1">This action cannot be undone.</p>
            </div>

            <div class="bg-gray-900/50 p-3 rounded-lg border border-red-500/20">
                <label class="block text-[10px] text-gray-500 uppercase tracking-wider font-bold mb-1.5 text-center">Type "<span class="text-red-400 select-all">delete</span>" to confirm</label>
                <input type="text" id="delete-confirmation-input" 
                       class="w-full bg-gray-800 text-white text-center font-bold border border-gray-600 rounded-lg p-2 focus:border-red-500 focus:ring-1 focus:ring-red-500 outline-none transition-all uppercase placeholder-gray-600"
                       placeholder="DELETE"
                       oninput="validateDeleteInput(this)">
            </div>

            <div class="flex gap-3 mt-1">
                <button onclick="closeDeleteModal()" class="flex-1 py-3 text-gray-400 font-medium hover:text-white rounded-xl hover:bg-gray-700 transition-colors">Cancel</button>
                <button id="btn-confirm-delete" onclick="executeDelete()" disabled class="flex-1 py-3 bg-gray-700 text-gray-500 font-bold rounded-xl transition-all cursor-not-allowed flex justify-center items-center gap-2">
                    <span>Delete</span>
                </button>
            </div>
        </div>
    </div>

    <div id="view-lightbox" class="fixed inset-0 z-[90] hidden bg-black/95 backdrop-blur flex flex-col items-center justify-center transition-opacity">
        
        <div class="absolute top-0 left-0 right-0 p-4 pt-6 bg-gradient-to-b from-black/90 to-transparent z-20 flex justify-between items-start pointer-events-none">
            <div class="flex-1 max-w-md pointer-events-auto">
                <label class="text-[10px] uppercase text-gray-500 font-bold tracking-wider ml-1">Document Name</label>
                <div class="flex items-center gap-2">
                    <input type="text" id="lightbox-filename" 
                           class="bg-transparent text-white text-lg font-bold border-b border-gray-700 focus:border-emerald-500 focus:bg-gray-900/50 outline-none w-full py-1 transition-colors" 
                           placeholder="Document Name"
                           onchange="saveDocumentRename()"> <span class="text-gray-600 text-sm font-mono pt-1 select-none">.webp</span>
                </div>
                <p id="rename-feedback" class="text-[10px] text-emerald-500 h-4 opacity-0 transition-opacity font-medium mt-1">Saved!</p>
            </div>
            
            <button onclick="closeLightbox()" class="text-gray-400 hover:text-white p-2 bg-black/20 rounded-full backdrop-blur pointer-events-auto ml-4">
                <i data-lucide="x" class="w-6 h-6"></i>
            </button>
        </div>

        <div class="flex-1 w-full flex items-center justify-center p-4 pt-20 pb-24 overflow-hidden">
             <img id="lightbox-img" class="max-w-full max-h-full object-contain shadow-2xl rounded-lg" src="">
        </div>

        <div class="absolute bottom-8 flex gap-4 z-20">
             <button onclick="closeLightbox()" class="px-6 py-3 bg-gray-800 rounded-xl text-white border border-gray-700 font-medium active:scale-95 transition-transform shadow-lg shadow-black/50">Close</button>
             <button id="lightbox-edit-btn" class="px-6 py-3 bg-emerald-600 rounded-xl text-white font-bold shadow-lg shadow-emerald-500/20 active:scale-95 transition-transform flex items-center gap-2">
                <i data-lucide="pen-tool" class="w-4 h-4"></i> Edit Image
             </button>
        </div>
    </div>

    <script src="https://docs.opencv.org/4.7.0/opencv.js" defer></script>
    <script src="https://cdn.jsdelivr.net/gh/ColonelParrot/jscanify@master/src/jscanify.min.js" defer></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/fabric.js/5.3.1/fabric.min.js" defer></script>
    <script src="https://cdn.jsdelivr.net/npm/cbor-js@0.1.0/cbor.min.js" defer></script>
    <script src="https://unpkg.com/lucide@latest"></script>
    <script src="https://cdn.jsdelivr.net/npm/tesseract.js@5/dist/tesseract.min.js" defer></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jspdf/2.5.1/jspdf.umd.min.js" defer></script>

    <script src="https://www.gstatic.com/firebasejs/10.7.1/firebase-app-compat.js" defer></script>
    <script src="https://www.gstatic.com/firebasejs/10.7.1/firebase-firestore-compat.js" defer></script>
    <script src="https://www.gstatic.com/firebasejs/10.7.1/firebase-auth-compat.js" defer></script>

    <script>
        // CONFIG
        const firebaseConfig = {
            apiKey: "AIzaSyAOEhir1NRj8LdnFfx1rQwu4fE82VBfd98",
            authDomain: "docuflowhq.firebaseapp.com",
            projectId: "docuflowhq",
            storageBucket: "docuflowhq.firebasestorage.app",
            messagingSenderId: "1091273480971",
            appId: "1:1091273480971:web:bcc5602a409ed3371fa00e"
        };
        const STORAGE_LIMIT_MB = 900; 

        // STATE
        let db = null;
        let jobs = []; 
        let archivedJobs = [];
        let isViewingArchive = false;
        let currentJobId = null;
        let scanner = null;
        let stream = null;
        let fabricCanvas = null;
        let isScanning = false;
        let currentFilterIndex = 0; 
        let currentSearchTerm = "";
        let editingDocId = null;
        let pendingDownloadDocId = null; // Track doc waiting for download
        let viewingDocId = null; // Track doc currently in lightbox
        let batchQueue = []; // Stores images for multi-page documents
        let isPdfBatch = false; // Track if we are processing a multi-page PDF

        // --- 2. HELPERS (Must be first) ---
        function parseSizeToBytes(sizeStr) {
            if(!sizeStr) return 0;
            const match = sizeStr.match(/([\d.]+)\s*(kb|mb|gb|b)/i);
            if(!match) return 0;
            const num = parseFloat(match[1]);
            const unit = match[2].toLowerCase();
            if(unit === 'kb') return num * 1024;
            if(unit === 'mb') return num * 1024 * 1024;
            if(unit === 'gb') return num * 1024 * 1024 * 1024;
            return num;
        }

        function calculateTotalUsage() {
            let totalBytes = 0;
            if(jobs) {
                jobs.forEach(job => {
                    if(job.documents) {
                        job.documents.forEach(doc => { totalBytes += parseSizeToBytes(doc.size); });
                    }
                });
            }
            return totalBytes;
        }

       function getJobStatus(job) {
            if(!job || !job.documents) return 'Open';
            
            // LOGIC CHANGE: Job is complete only if a Delivery Order is signed
            const hasSignedDO = job.documents.some(d => d.docCategory === 'Delivery Order' && d.isSigned === true);
            
            return hasSignedDO ? 'Completed' : 'Open';
        }

        function getDocBadgesHTML(documents) {
            if(!documents) return '';
            const presentCats = new Set(documents.map(d => d.docCategory));
            
            // STRICT SEQUENCE: 
            // Quotation -> Purchase Request -> Purchase Order -> Service Report -> Delivery Order -> Invoice -> Others
            const badgeOrder = [
                { key: 'Quotation', label: 'QT', color: 'bg-purple-900/40 text-purple-300 border-purple-700/50' },
                { key: 'Purchase Request', label: 'PR', color: 'bg-orange-900/40 text-orange-300 border-orange-700/50' },
                { key: 'Purchase Order', label: 'PO', color: 'bg-emerald-900/40 text-emerald-300 border-emerald-700/50' },
                { key: 'Service Report', label: 'SR', color: 'bg-blue-900/40 text-blue-300 border-blue-700/50' },
                { key: 'Delivery Order', label: 'DO', color: 'bg-cyan-900/40 text-cyan-300 border-cyan-700/50' },
                { key: 'Invoice', label: 'INV', color: 'bg-pink-900/40 text-pink-300 border-pink-700/50' }, // <--- Moved Here
                
                // Catch-all / Others
                { key: 'Permit to Work', label: 'PTW', color: 'bg-red-900/40 text-red-300 border-red-700/50' },
                { key: 'Other', label: 'OTH', color: 'bg-gray-700/40 text-gray-400 border-gray-600/50' }
            ];

            let html = '';
            badgeOrder.forEach(badge => {
                if (presentCats.has(badge.key)) {
                    html += `<span class="text-[9px] px-1.5 py-0.5 rounded border ${badge.color} uppercase tracking-tight font-bold shadow-sm whitespace-nowrap">
                        <span class="md:hidden">${badge.label}</span>
                        <span class="hidden md:inline">${badge.key}</span>
                    </span>`;
                }
            });
            return html;
        }

        async function processPdfFile(file) {
            // UI Feedback
            const loader = document.createElement('div');
            loader.className = 'fixed inset-0 z-[100] bg-black/80 flex items-center justify-center flex-col text-emerald-400 font-bold';
            loader.innerHTML = '<div class="loader mb-4"></div>Processing PDF Pages...';
            document.body.appendChild(loader);

            try {
                const arrayBuffer = await file.arrayBuffer();
                const pdf = await pdfjsLib.getDocument(arrayBuffer).promise;
                
                // Clear existing queue
                batchQueue = [];
                isPdfBatch = true; // Set flag so save logic knows order

                // Loop through all pages
                for (let i = 1; i <= pdf.numPages; i++) {
                    const page = await pdf.getPage(i);
                    const scale = 2.0; // High res for good quality
                    const viewport = page.getViewport({ scale: scale });
                    
                    // Render to off-screen canvas
                    const canvas = document.createElement('canvas');
                    const context = canvas.getContext('2d');
                    canvas.height = viewport.height;
                    canvas.width = viewport.width;

                    await page.render({ canvasContext: context, viewport: viewport }).promise;
                    
                    const imgData = canvas.toDataURL('image/webp', 0.9);

                    if (i === 1) {
                        // Page 1 goes immediately to the Editor
                        closeScanner();
                        openEditor(imgData);
                    } else {
                        // Pages 2+ go to the queue waiting to be saved
                        batchQueue.push(imgData);
                    }
                }
                
                // Feedback
                const title = document.querySelector('#add-menu-modal h3');
                if(title) title.textContent = `PDF: ${pdf.numPages} Pages Loaded`;

            } catch (e) {
                console.error("PDF Error:", e);
                alert("Could not read PDF file.");
            } finally {
                document.body.removeChild(loader);
            }
        }
        // --- 3. CORE UI FUNCTIONS ---
       function updateStorageUI() {
            const totalBytes = calculateTotalUsage();
            const usedMB = (totalBytes / (1024 * 1024)).toFixed(1);
            const percentage = Math.min((usedMB / STORAGE_LIMIT_MB) * 100, 100);

            const textEl = document.getElementById('storage-text');
            if(textEl) textEl.textContent = `${usedMB} MB / ${STORAGE_LIMIT_MB} MB`;
            
            const bar = document.getElementById('storage-bar');
            if(bar) {
                bar.style.width = `${percentage}%`;
                if(percentage > 90) { bar.className = "h-full bg-red-500 w-0 transition-all duration-500"; }
                else if (percentage > 70) { bar.className = "h-full bg-yellow-500 w-0 transition-all duration-500"; }
                else { bar.className = "h-full bg-emerald-500 w-0 transition-all duration-500"; }
            }

            const alertBox = document.getElementById('archive-alert');
            
            // --- CHANGE IS HERE ---
            // Old logic: if(percentage >= 95 || hasCompleted)
            // New logic: Only show if storage is over 80% full
            if(alertBox) {
                if(percentage >= 80) { 
                    alertBox.classList.remove('hidden'); 
                } else { 
                    alertBox.classList.add('hidden'); 
                }
            }
        }

        function renderJobs() {
            const container = document.getElementById('job-container');
            let dataSource = jobs;
            
            if(isViewingArchive) {
                dataSource = archivedJobs;
                if(!document.getElementById('exit-archive-btn')) {
                    const btn = document.createElement('button');
                    btn.id = 'exit-archive-btn';
                    btn.textContent = 'Exit Archive View';
                    btn.className = 'mb-4 w-full py-2 bg-gray-800 border border-gray-600 rounded text-sm text-gray-300';
                    btn.onclick = () => { isViewingArchive = false; archivedJobs = []; renderJobs(); };
                    container.parentNode.insertBefore(btn, container);
                }
            } else {
                const exitBtn = document.getElementById('exit-archive-btn');
                if(exitBtn) exitBtn.remove();
            }

            let filteredJobs = dataSource;
            if (currentSearchTerm) {
                filteredJobs = dataSource.filter(job => {
                    const basicMatch = job.client.toLowerCase().includes(currentSearchTerm) || 
                                     job.id.toLowerCase().includes(currentSearchTerm);
                    if (basicMatch) return true;
                    if(job.documents) {
                        const docMatch = job.documents.some(doc => 
                            doc.ocrText && doc.ocrText.toLowerCase().includes(currentSearchTerm)
                        );
                        return docMatch;
                    }
                    return false;
                });
            }

            if (!filteredJobs || filteredJobs.length === 0) {
                container.innerHTML = `<div class="text-center text-gray-500 py-10">No jobs found. Click + to start.</div>`;
                return;
            }

            const sortedJobs = [...filteredJobs].sort((a, b) => b.id.localeCompare(a.id));

            container.innerHTML = sortedJobs.map(job => {
                const status = getJobStatus(job);
                const statusColor = status === 'Completed' ? 'bg-emerald-900/30 text-emerald-400 border-emerald-900/50' : 'bg-yellow-900/30 text-yellow-400 border-yellow-900/50';
                const borderClass = isViewingArchive ? 'border-purple-500/50' : 'border-gray-700';

                return `
                <div onclick="openJobDetails('${job.id}')" class="bg-gray-800 p-4 rounded-xl border ${borderClass} active:bg-gray-700 transition-colors cursor-pointer flex justify-between items-center group relative overflow-hidden">
                    <div class="absolute left-0 top-0 bottom-0 w-1 ${status === 'Completed' ? 'bg-emerald-500' : 'bg-yellow-500'}"></div>
                    <div class="pl-3 w-full">
                        <div class="flex items-center justify-between mb-1">
                            <div class="flex items-center gap-2"><span class="text-xs font-mono text-gray-500">#${job.id}</span><span class="text-[10px] px-2 py-0.5 rounded border ${statusColor} font-bold tracking-wider uppercase">${status}</span></div>
                            <span class="text-[10px] text-gray-500 mr-2">${job.date}</span>
                        </div>
                        <h3 class="font-bold text-white group-hover:text-emerald-400 transition-colors mb-2">${job.client}</h3>
                        <div class="flex flex-wrap gap-1.5 min-h-[1.25rem]">${getDocBadgesHTML(job.documents)}</div>
                    </div>
                    <div class="flex items-center justify-center pl-2 border-l border-gray-700/50"><i data-lucide="chevron-right" class="w-5 h-5 text-gray-500 group-hover:text-white transition-colors"></i></div>
                </div>
            `}).join('');
            if(typeof lucide !== 'undefined') lucide.createIcons();
        }

        // --- 4. DATA LOGIC ---
        function loadJobsFromFirestore() {
            if (!db) return;
            db.collection('jobs').onSnapshot((snapshot) => {
                const loadedJobs = [];
                snapshot.forEach((doc) => { loadedJobs.push(doc.data()); });
                jobs = loadedJobs;
                renderJobs();
                updateStorageUI();
            }, (error) => console.error("Error syncing jobs:", error));
        }

        function updateConnectionStatus(isOnline) {
            const statusEl = document.getElementById('connection-status');
            if (isOnline) statusEl.innerHTML = '<div class="w-2 h-2 rounded-full bg-emerald-500 animate-pulse"></div> Online';
            else statusEl.innerHTML = '<div class="w-2 h-2 rounded-full bg-red-500"></div> Offline';
        }

        function initFirebase() {
            if (typeof firebase !== 'undefined') {
                try {
                    const app = firebase.initializeApp(firebaseConfig);
                    const firestore = firebase.firestore();
                    firestore.enablePersistence().catch(err => console.warn('Persistence warning:', err.code));
                    firebase.auth().signInAnonymously()
                        .then(() => {
                            console.log("ðŸ‘¤ Signed in Anonymously");
                            db = firestore; 
                            updateConnectionStatus(true);
                            loadJobsFromFirestore();
                        })
                        .catch((error) => {
                            console.error("Auth Failed", error);
                            updateConnectionStatus(false);
                            if (error.code === 'auth/configuration-not-found' || error.code === 'auth/operation-not-allowed') {
                                alert("Configuration Error: Enable Anonymous Auth in Firebase Console.");
                            }
                        });
                } catch (e) {
                    console.error("Firebase Init Failed:", e);
                    updateConnectionStatus(false);
                }
            } else { updateConnectionStatus(false); }
        }

        // --- 5. ACTION HANDLERS ---
        function openNewJobModal() {
            if(isViewingArchive) return alert("Please exit archive view.");
            document.getElementById('new-job-modal').classList.remove('hidden');
            document.getElementById('new-job-title').focus();
        }
        function closeNewJobModal() {
            document.getElementById('new-job-modal').classList.add('hidden');
            document.getElementById('new-job-title').value = '';
        }
        function confirmNewJob() {
            const titleInput = document.getElementById('new-job-title');
            const title = titleInput.value.trim();
            if (!title) return alert("Please enter a job title.");
            const newId = 'J-' + Math.floor(1000 + Math.random() * 9000);
            const dateStr = new Date().toLocaleDateString('en-US', { month: 'short', day: 'numeric' });
            
            const newJob = { id: newId, client: title, date: dateStr, documents: [] };
            if (db) { db.collection('jobs').doc(newId).set(newJob).catch(e => console.error(e)); }
            
            closeNewJobModal();
        }

        // --- DETAILS ---
        function openJobDetails(id) {
            currentJobId = id;
            const sourceList = isViewingArchive ? archivedJobs : jobs;
            const job = sourceList.find(j => j.id === id);
            const status = getJobStatus(job);
            
            document.getElementById('detail-client').textContent = job.client;
            document.getElementById('detail-id').textContent = '#' + job.id;
            const statusEl = document.getElementById('detail-status');
            statusEl.textContent = status;
            statusEl.className = status === 'Completed'
                ? 'text-[10px] px-2 py-1 rounded bg-emerald-900/50 text-emerald-400 font-bold uppercase tracking-wider border border-emerald-800'
                : 'text-[10px] px-2 py-1 rounded bg-yellow-900/50 text-yellow-400 font-bold uppercase tracking-wider border border-yellow-800';

            const scanFab = document.getElementById('scan-fab');
            const archiveBadge = document.getElementById('detail-archive-badge');
            if (isViewingArchive) { scanFab.classList.add('hidden'); archiveBadge.classList.remove('hidden'); } 
            else { scanFab.classList.remove('hidden'); archiveBadge.classList.add('hidden'); }
            
            renderDocumentList(job);
            document.getElementById('view-job-details').classList.remove('hidden');
        }
        function closeJobDetails() {
            document.getElementById('view-job-details').classList.add('hidden');
            currentJobId = null;
        }

        function renderDocumentList(job) {
            const list = document.getElementById('document-list');
            const emptyState = document.getElementById('empty-docs');
            
            if (!job.documents || job.documents.length === 0) { 
                list.innerHTML = ''; 
                emptyState.classList.remove('hidden'); 
                return; 
            }
            emptyState.classList.add('hidden');
            
            // SORTING LOGIC
            const sortWeights = {
                'Quotation': 1,
                'Purchase Request': 2,
                'Purchase Order': 3,
                'Service Report': 4,
                'Delivery Order': 5,
                'Invoice': 6,
                'Permit to Work': 7,
                'Other': 99 
            };

            const sortedDocs = [...job.documents].sort((a, b) => {
                // 1. Primary Sort: Category Weight
                const weightA = sortWeights[a.docCategory] || 99;
                const weightB = sortWeights[b.docCategory] || 99;
                
                if (weightA !== weightB) {
                    return weightA - weightB;
                }
                
                // 2. Secondary Sort: Handle Multi-page Bundles
                // We strip the "(Page X)" suffix to see if they are the same base document
                const getBaseName = (name) => name.replace(/\s*\(Page\s+\d+\).*/i, '');
                const baseA = getBaseName(a.name);
                const baseB = getBaseName(b.name);

                if (baseA === baseB) {
                    // IF SAME DOCUMENT: Sort Ascending by Name (Page 1 -> Page 2 -> Page 3)
                    // { numeric: true } ensures "Page 10" comes after "Page 2", not before.
                    return a.name.localeCompare(b.name, undefined, { numeric: true });
                }

                // 3. Tertiary Sort: Different Documents -> Newest First (Descending ID)
                return b.id.localeCompare(a.id); 
            });

            list.innerHTML = sortedDocs.map(doc => {
                let icon = 'file-text';
                if (doc.type === 'img' || doc.type === 'scan') icon = 'image';
                if (doc.type === 'pdf') icon = 'file';
                
                // CHANGED: Identify Delivery Order instead of PO
                const isDO = doc.docCategory === 'Delivery Order';
                
                const displayName = doc.name.replace(/\.[^/.]+$/, "");

                let actionButtons = '';
                if (isViewingArchive) {
                    actionButtons = `<button onclick="event.stopPropagation()" class="p-2 text-gray-500 cursor-not-allowed border border-gray-700 rounded"><i data-lucide="lock" class="w-4 h-4"></i></button>`;
                } else {
                    // Edit Button
                    actionButtons += `<button onclick="event.stopPropagation(); editExistingDoc('${doc.id}')" class="p-2 text-blue-400 hover:text-white bg-blue-900/20 rounded border border-blue-900/50 mr-2"><i data-lucide="pen-tool" class="w-4 h-4"></i></button>`;
                    
                    // Delete Button (New)
                    actionButtons += `<button onclick="event.stopPropagation(); promptDelete('${doc.id}')" class="p-2 text-red-400 hover:text-white bg-red-900/20 rounded border border-red-900/50"><i data-lucide="trash-2" class="w-4 h-4"></i></button>`;
                }

                let metaHtml = '';
                if (doc.smartData) {
                    if (doc.smartData.id) metaHtml += `<span class="text-[9px] text-emerald-300 bg-emerald-900/40 px-1.5 py-0.5 rounded mr-1 font-mono tracking-wide border border-emerald-800">${doc.smartData.id}</span>`;
                    if (doc.smartData.amount) metaHtml += `<span class="text-[9px] text-yellow-300 bg-yellow-900/40 px-1.5 py-0.5 rounded font-mono border border-yellow-800">\$${doc.smartData.amount}</span>`;
                }

                return `
                <div onclick="viewDocument('${doc.id}')" class="bg-gray-800 p-3 rounded-lg border border-gray-700 flex justify-between items-center cursor-pointer hover:bg-gray-700/50 transition-colors group">
                    <div class="flex items-center gap-3">
                        <div class="w-10 h-10 rounded bg-gray-900 flex items-center justify-center text-gray-400 relative group-hover:text-white transition-colors">
                            <i data-lucide="${icon}" class="w-5 h-5"></i>
                            ${doc.isSigned ? '<div class="absolute -bottom-1 -right-1 bg-emerald-500 rounded-full p-0.5 border border-gray-900"><svg width="8" height="8" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="4"><polyline points="20 6 9 17 4 12"></polyline></svg></div>' : (isDO ? '<div class="absolute -top-1 -right-1 w-3 h-3 bg-yellow-500 rounded-full border border-gray-900"></div>' : '')}
                        </div>
                        <div>
                            <div class="flex items-center gap-2 mb-0.5">
                                <p class="text-sm font-medium text-gray-200 group-hover:text-emerald-400 transition-colors">${displayName}</p>
                            </div>
                            <div class="flex items-center gap-1">
                                <span class="text-[9px] px-1.5 py-0.5 rounded border border-gray-600/50 text-gray-400 uppercase font-bold">${doc.docCategory}</span>
                                ${metaHtml}
                            </div>
                        </div>
                    </div>
                    <div class="flex gap-2">
                        <button onclick="event.stopPropagation(); downloadSinglePDF('${doc.id}')" class="p-2 text-red-400 hover:text-white bg-red-900/20 rounded border border-red-900/50"><i data-lucide="file-text" class="w-4 h-4"></i></button>
                        ${actionButtons}
                    </div>
                </div>
            `}).join('');
            if(typeof lucide !== 'undefined') lucide.createIcons();
        }
        // --- SCANNER / EDITOR ---
        function editExistingDoc(docId) {
            if(isViewingArchive) return;
            editingDocId = docId;
            const job = jobs.find(j => j.id === currentJobId);
            const doc = job.documents.find(d => d.id === docId);
            if(!doc) return;
            const btn = event.currentTarget; 
            const originalIcon = btn.innerHTML;
            btn.innerHTML = '<div class="loader w-4 h-4 border-t-blue-500"></div>';
            ensureDocImageLoaded(job, doc).then(imgSrc => {
                btn.innerHTML = originalIcon;
                if (imgSrc) {
                    document.getElementById('view-job-details').classList.add('hidden');
                    openEditor(imgSrc);
                } else { alert("Could not load image. It might be missing from cloud or offline."); }
            });
        }

        function viewDocument(docId) {
            const job = jobs.find(j => j.id === currentJobId);
            const doc = job.documents.find(d => d.id === docId);
            if(!doc) return;

            viewingDocId = docId; // Store ID for renaming

            // UI Loading State
            document.body.style.cursor = 'wait';

            ensureDocImageLoaded(job, doc).then(imgSrc => {
                document.body.style.cursor = 'default';
                if (imgSrc) {
                    const lightbox = document.getElementById('view-lightbox');
                    const img = document.getElementById('lightbox-img');
                    const editBtn = document.getElementById('lightbox-edit-btn');
                    const nameInput = document.getElementById('lightbox-filename');
                    
                    // Setup Image
                    img.src = imgSrc;
                    
                    // Setup Name (Strip extension for display)
                    nameInput.value = doc.name.replace(/\.[^/.]+$/, "");
                    
                    // Setup Edit Button
                    editBtn.onclick = (e) => { 
                        e.stopPropagation();
                        closeLightbox(); 
                        editingDocId = docId;
                        openEditor(imgSrc); 
                    };
                    
                    lightbox.classList.remove('hidden');
                } else {
                    alert("Image not available.");
                }
            });
        }

        // --- DELETE LOGIC ---
        let pendingDeleteId = null;

        function promptDelete(docId) {
            pendingDeleteId = docId;
            const modal = document.getElementById('delete-modal');
            const input = document.getElementById('delete-confirmation-input');
            const btn = document.getElementById('btn-confirm-delete');
            
            // Reset State
            input.value = '';
            btn.disabled = true;
            btn.className = "flex-1 py-3 bg-gray-700 text-gray-500 font-bold rounded-xl transition-all cursor-not-allowed flex justify-center items-center gap-2";
            
            // Show Modal
            modal.classList.remove('hidden');
            // Small delay for fade-in effect
            setTimeout(() => modal.classList.remove('opacity-0'), 10);
            setTimeout(() => input.focus(), 100);
        }

        function closeDeleteModal() {
            const modal = document.getElementById('delete-modal');
            modal.classList.add('opacity-0');
            setTimeout(() => {
                modal.classList.add('hidden');
                pendingDeleteId = null;
            }, 200);
        }

        function validateDeleteInput(input) {
            const btn = document.getElementById('btn-confirm-delete');
            const val = input.value.trim().toLowerCase();
            
            if (val === 'delete') {
                // Enable Button (Turn Red)
                btn.disabled = false;
                btn.className = "flex-1 py-3 bg-red-600 text-white hover:bg-red-500 font-bold rounded-xl shadow-lg shadow-red-900/40 active:scale-95 transition-all flex justify-center items-center gap-2";
            } else {
                // Disable Button (Turn Gray)
                btn.disabled = true;
                btn.className = "flex-1 py-3 bg-gray-700 text-gray-500 font-bold rounded-xl transition-all cursor-not-allowed flex justify-center items-center gap-2";
            }
        }

        async function executeDelete() {
            if (!pendingDeleteId || !currentJobId) return;
            
            const btn = document.getElementById('btn-confirm-delete');
            btn.innerHTML = '<div class="loader w-4 h-4 border-t-white"></div>';
            
            try {
                // 1. Find the full document object from our local list
                // We need the full object to remove it from the 'documents' array properly
                const job = jobs.find(j => j.id === currentJobId);
                const docToDelete = job.documents.find(d => d.id === pendingDeleteId);

                if (!docToDelete) throw new Error("Document not found");

                // 2. Database Operation
                if (db) {
                    const jobRef = db.collection('jobs').doc(currentJobId);
                    
                    // A. Remove from the 'documents' array metadata
                    await jobRef.update({
                        documents: firebase.firestore.FieldValue.arrayRemove(docToDelete)
                    });

                    // B. Delete the actual subcollection document (the binary data)
                    await jobRef.collection('scans').doc(pendingDeleteId).delete();
                } else {
                    // Offline Fallback
                    const idx = job.documents.findIndex(d => d.id === pendingDeleteId);
                    if (idx > -1) job.documents.splice(idx, 1);
                }

                // 3. UI Cleanup
                closeDeleteModal();
                
                // If viewing details, refresh the list immediately
                if (currentJobId) {
                    // Re-fetch local data reference to ensure we render correct state
                    const updatedJob = jobs.find(j => j.id === currentJobId);
                    // If we are offline, we manually updated 'job', so it's fine. 
                    // If online, the snapshot listener in loadJobsFromFirestore will auto-update, 
                    // but we call this for instant feedback:
                    renderDocumentList(updatedJob);
                }

            } catch (err) {
                console.error("Delete failed:", err);
                alert("Failed to delete document.");
                closeDeleteModal();
            }
        }
        
        async function saveDocumentRename() {
            if (!viewingDocId || !currentJobId) return;

            const nameInput = document.getElementById('lightbox-filename');
            const feedback = document.getElementById('rename-feedback');
            const cleanName = nameInput.value.trim();
            
            if (!cleanName) return; // Don't save empty names

            const finalName = cleanName + '.webp';

            // 1. Update Local Data
            const job = jobs.find(j => j.id === currentJobId);
            const doc = job.documents.find(d => d.id === viewingDocId);
            if (doc) {
                doc.name = finalName;
                renderDocumentList(job); // Refresh list behind the modal
            }

            // 2. Show "Saved" feedback
            feedback.classList.remove('opacity-0');
            setTimeout(() => feedback.classList.add('opacity-0'), 2000);

            // 3. Update Firebase (Background)
            if (db) {
                try {
                    const jobRef = db.collection('jobs').doc(currentJobId);
                    const jobSnap = await jobRef.get();
                    if (jobSnap.exists) {
                        let currentDocs = jobSnap.data().documents;
                        const idx = currentDocs.findIndex(d => d.id === viewingDocId);
                        if (idx !== -1) {
                            currentDocs[idx].name = finalName;
                            await jobRef.update({ documents: currentDocs });
                            
                            // Optional: Update the actual scan document metadata too
                            await db.collection('jobs').doc(currentJobId).collection('scans').doc(viewingDocId).update({ name: finalName });
                        }
                    }
                } catch (e) {
                    console.error("Rename failed:", e);
                    feedback.textContent = "Error saving";
                    feedback.classList.add('text-red-500');
                }
            }
        }

        function closeLightbox() {
            document.getElementById('view-lightbox').classList.add('hidden');
            viewingDocId = null;
            setTimeout(() => { document.getElementById('lightbox-img').src = ''; }, 200);
        }

        async function ensureDocImageLoaded(job, doc) {
            // 1. If we already have the image in memory, return it
            if (doc.src && doc.src.length > 100) return doc.src;
            
            // 2. If viewing an archive, we can't fetch from DB
            if (isViewingArchive) return null;
            
            // 3. Fetch from Firebase
            if (db && doc.id) {
                try {
                    const docRef = db.collection('jobs').doc(job.id).collection('scans').doc(doc.id);
                    const snapshot = await docRef.get();
                    if (snapshot.exists) {
                        const data = snapshot.data();
                        if (data.image_blob) {
                            // Convert Firebase Blob to Object URL
                            const uint8Array = data.image_blob.toUint8Array();
                            const blob = new Blob([uint8Array], { type: 'image/webp' });
                            const url = URL.createObjectURL(blob);
                            doc.src = url; // Cache it locally
                            return url;
                        } else if (data.src) {
                            doc.src = data.src;
                            return data.src;
                        }
                    }
                } catch (e) { console.error("Error fetching image:", e); }
            }
            return null;
        }

        function handleAddPage() {
            if (!fabricCanvas) return;

            // 1. Get current image
            const multiplier = 2; // Better quality for storage
            const dataURL = fabricCanvas.toDataURL({ format: 'webp', quality: 0.9, multiplier: multiplier });

            // 2. Add to Queue
            batchQueue.push(dataURL);

            // 3. Feedback
            const btn = event.currentTarget;
            const originalText = btn.innerHTML;
            btn.innerHTML = `<span class='text-green-400'>Added!</span>`;
            
            setTimeout(() => {
                // 4. Reset for next page
                btn.innerHTML = originalText;
                document.getElementById('view-editor').classList.add('hidden');
                
                // Open Add Menu directly so user can choose Camera/Upload/Paste again
                openAddMenu();
                
                // Optional: Update Add Menu title to show page count
                const title = document.querySelector('#add-menu-modal h3');
                if(title) title.textContent = `Add Page ${batchQueue.length + 1}`;
            }, 400);
        }

        function openScanner() {
            editingDocId = null;
            document.getElementById('view-scanner').classList.remove('hidden');
            const feedback = document.getElementById('scan-feedback');
            feedback.classList.remove('hidden'); feedback.classList.add('flex');
            const video = document.getElementById('video');
            const highlightCanvas = document.getElementById('highlight-canvas');
            const canvasCtx = highlightCanvas.getContext('2d');
            navigator.mediaDevices.getUserMedia({ video: { facingMode: "environment" } }).then((s) => {
                stream = s; video.srcObject = stream; isScanning = true;
                document.querySelector('.scanner-overlay')?.classList.add('scanning');
                const scanLoop = () => {
                    if (!isScanning) return;
                    if (video.readyState === video.HAVE_ENOUGH_DATA && scanner) {
                        highlightCanvas.width = video.videoWidth; highlightCanvas.height = video.videoHeight;
                        canvasCtx.clearRect(0, 0, highlightCanvas.width, highlightCanvas.height);
                        try { scanner.highlightPaper(highlightCanvas, video); } catch(e) {}
                    }
                    requestAnimationFrame(scanLoop);
                };
                scanLoop();
            }).catch(err => { console.warn(err); alert("Camera unavailable. Use upload/paste."); });
        }
        function closeScanner() {
            isScanning = false; if (stream) stream.getTracks().forEach(track => track.stop());
            document.getElementById('view-scanner').classList.add('hidden');
        }
        function triggerDocUpload() { document.getElementById('doc-upload-input').click(); }
        function handleDocUpload(input) {
            editingDocId = null;
            if (input.files && input.files[0]) {
                const file = input.files[0];
                
                // CHECK FOR PDF
                if (file.type === 'application/pdf') {
                    processPdfFile(file);
                    input.value = '';
                    return;
                }

                // Standard Image Logic
                if (!file.type.startsWith('image/')) { 
                    alert("âš ï¸ Restricted Format\n\nOnly Images and PDFs are allowed."); 
                    input.value = ''; 
                    return; 
                }
                
                // Normal Image Upload
                isPdfBatch = false; // Reset flag
                const reader = new FileReader();
                reader.onload = function(e) { closeScanner(); openEditor(e.target.result); }
                reader.readAsDataURL(file);
            }
            input.value = ''; 
        }
        function triggerStampInput() { document.getElementById('stamp-input').click(); }
        function processStampUpload(input) {
            if (input.files && input.files[0]) {
                const reader = new FileReader();
                
                reader.onload = function(e) {
                    // Use the shared helper! 
                    // This ensures Uploads get the same "Background Removal" treatment as Pastes.
                    processAndAddStamp(e.target.result); 
                    
                    input.value = ''; // Reset so you can select the same file again
                };
                
                reader.readAsDataURL(input.files[0]);
            }
        }
        
        function toggleStampMenu() {
            const menu = document.getElementById('stamp-options-menu');
            menu.classList.toggle('hidden');
        }

        // Close menu if clicking elsewhere
        document.addEventListener('click', function(e) {
            const menu = document.getElementById('stamp-options-menu');
            const btn = e.target.closest('button[onclick="toggleStampMenu()"]');
            const insideMenu = e.target.closest('#stamp-options-menu');
            
            if (!btn && !insideMenu && !menu.classList.contains('hidden')) {
                menu.classList.add('hidden');
            }
        });

        async function handlePasteButton() {
            try {
                // Try to read clipboard data programmatically
                const clipboardItems = await navigator.clipboard.read();
                for (const item of clipboardItems) {
                    if (item.types.some(type => type.startsWith('image/'))) {
                        const blob = await item.getType(item.types.find(type => type.startsWith('image/')));
                        const reader = new FileReader();
                        reader.onload = (e) => processAndAddStamp(e.target.result);
                        reader.readAsDataURL(blob);
                        return;
                    }
                }
                alert("No image found in clipboard.");
            } catch (err) {
                // Fallback if browser blocks clipboard access
                console.warn("Clipboard access denied or not supported:", err);
                alert("Please press Ctrl+V (or Cmd+V) on your keyboard to paste.");
            }
        }
        
        function addStampImageToCanvas(dataUrl) {
            if (!fabricCanvas) return;
            
            fabric.Image.fromURL(dataUrl, function(img) {
                // 1. Calculate Scale
                const targetScale = (fabricCanvas.width * 0.3) / img.width;

                img.set({
                    left: fabricCanvas.width / 2,
                    top: fabricCanvas.height / 2,
                    originX: 'center',
                    originY: 'center',
                    scaleX: targetScale,
                    scaleY: targetScale,
                    cornerColor: '#10b981', // Emerald 500
                    cornerStyle: 'circle',
                    borderColor: '#10b981',
                    transparentCorners: false,
                    
                    // CUSTOM PROPERTIES
                    isStamp: true,     // Tag it so we know it's a stamp
                    rawSrc: dataUrl    // IMPORTANT: Keep original for re-processing
                });

                fabricCanvas.add(img);
                fabricCanvas.setActiveObject(img);
                
                // Trigger initial cleanup with default value (150)
                updateStampThreshold(150);
            });
        }

        function processAndAddStamp(rawImgSrc) {
            // We no longer pre-process here. We pass the raw image to the canvas
            // and let the slider logic handle the processing. 
            // This ensures the slider always has the original data to work with.
            addStampImageToCanvas(rawImgSrc);
        }

        // --- STAMP SLIDER LOGIC ---

        // 1. Listen for selection events to Show/Hide slider
        function initFabricListeners() {
            if(!fabricCanvas) return;

            fabricCanvas.on('selection:created', (e) => checkSelection(e.selected[0]));
            fabricCanvas.on('selection:updated', (e) => checkSelection(e.selected[0]));
            fabricCanvas.on('selection:cleared', () => hideStampSlider());
        }

        function checkSelection(obj) {
            if (obj && obj.isStamp) {
                // It is a stamp, show the slider
                document.getElementById('stamp-slider-container').classList.remove('hidden');
                // Reset slider to a middle value or the last used value if we stored it
                // document.getElementById('stamp-threshold').value = 150; 
            } else {
                hideStampSlider();
            }
        }

        function hideStampSlider() {
            document.getElementById('stamp-slider-container').classList.add('hidden');
        }

        // 2. The Slider Function
        function updateStampThreshold(thresholdVal) {
            if (!fabricCanvas) return;
            const activeObj = fabricCanvas.getActiveObject();
            
            if (!activeObj || !activeObj.isStamp || !activeObj.rawSrc) return;

            const threshold = parseInt(thresholdVal);
            const rawSrc = activeObj.rawSrc;

            const tempImg = new Image();
            tempImg.src = rawSrc;
            
            tempImg.onload = function() {
                const canvas = document.createElement('canvas');
                const ctx = canvas.getContext('2d');
                canvas.width = tempImg.width;
                canvas.height = tempImg.height;
                
                ctx.drawImage(tempImg, 0, 0);
                
                const imgData = ctx.getImageData(0, 0, canvas.width, canvas.height);
                const data = imgData.data;

                // PIXEL MANIPULATION LOOP
                for (let i = 0; i < data.length; i += 4) {
                    const r = data[i];
                    const g = data[i + 1];
                    const b = data[i + 2];
                    
                    // Calculate brightness
                    const brightness = (r + g + b) / 3;

                    if (brightness > threshold) {
                        // If it is brighter than threshold, make it transparent
                        data[i + 3] = 0; 
                    } 
                    // REMOVED THE 'ELSE' BLOCK
                    // By doing nothing here, we keep the original R, G, B colors!
                }

                ctx.putImageData(imgData, 0, 0);
                
                // Update the fabric object
                const newSrc = canvas.toDataURL();
                activeObj.setSrc(newSrc, function() {
                    fabricCanvas.renderAll();
                });
            };
        }

        function addTextToCanvas() {
            if (!fabricCanvas) return;
            
            // Create a text object
            // 'IText' allows the user to double-click and edit the text on canvas
            const text = new fabric.IText('Tap to Edit', {
                left: fabricCanvas.width / 2,
                top: fabricCanvas.height / 2,
                fontFamily: 'Calibri',
                fill: '#000000', // Bright red so it stands out
                fontSize: 24,
                fontWeight: 'bold',
                originX: 'center',
                originY: 'center',
                cornerColor: 'blue',
                cornerStyle: 'circle',
                borderColor: 'blue',
                transparentCorners: false
            });

            fabricCanvas.add(text);
            fabricCanvas.setActiveObject(text); // Select it immediately
            fabricCanvas.renderAll();
        }
        
        function cancelEdit() {
            document.getElementById('view-editor').classList.add('hidden');
            if(fabricCanvas) { try { fabricCanvas.dispose(); } catch(e){} fabricCanvas = null; }
            batchQueue = []; 
            isPdfBatch = false;
            const title = document.querySelector('#add-menu-modal h3');
            if(title) title.textContent = 'Add Document';

            if(currentJobId) openJobDetails(currentJobId); 
        }

        async function handlePasteClick() {
            editingDocId = null;
            try {
                const items = await navigator.clipboard.read();
                for (const item of items) {
                    if (item.types.includes('image/png') || item.types.includes('image/jpeg')) {
                        const blob = await item.getType(item.types.find(t => t.startsWith('image/')));
                        const reader = new FileReader();
                        reader.onload = (e) => { closeAddMenu(); openEditor(e.target.result); };
                        reader.readAsDataURL(blob);
                        return;
                    }
                }
                alert("No image found in clipboard.");
            } catch (err) { console.warn(err); alert("Use Ctrl+V to paste."); }
        }

        function setupPasteListener() {
            document.addEventListener('paste', function(e) {
                // 1. Check if we have a valid context (Job or specific view)
                if (!currentJobId && document.getElementById('view-editor').classList.contains('hidden')) return;

                // 2. extract the file
                const items = (e.clipboardData || e.originalEvent.clipboardData).items;
                let blob = null;
                for (let i = 0; i < items.length; i++) {
                    if (items[i].type.indexOf("image") === 0) { blob = items[i].getAsFile(); break; }
                }

                if (blob !== null) {
                    e.preventDefault();
                    const reader = new FileReader();
                    
                    reader.onload = function(event) { 
                        const editorView = document.getElementById('view-editor');
                        
                        // === LOGIC BRANCH ===
                        if (!editorView.classList.contains('hidden')) {
                            // A. Editor is OPEN -> Add as STAMP (Process background)
                            processAndAddStamp(event.target.result);
                        } else {
                            // B. Editor is CLOSED -> Create NEW DOCUMENT
                            closeAddMenu(); 
                            closeScanner(); 
                            openEditor(event.target.result); 
                        }
                    };
                    reader.readAsDataURL(blob);
                } else {
                    // Feedback if user pastes non-image
                    // Only show alert if we found items but no images (avoid alerting on text paste in inputs)
                    if (items.length > 0 && items[0].kind === 'file') {
                         alert("âš ï¸ Only Images are allowed.");
                    }
                }
            });
        }

        function openEditor(imageInput) {
            document.getElementById('view-editor').classList.remove('hidden');
            const container = document.getElementById('view-editor').querySelector('.flex-1');
            const canvasWrapper = document.getElementById('canvas-wrapper');
            const maxWidth = container.clientWidth - 40; const maxHeight = container.clientHeight - 40;
            
            if (fabricCanvas) { try { fabricCanvas.dispose(); } catch (e) {} fabricCanvas = null; }
            canvasWrapper.innerHTML = '<canvas id="fabric-canvas"></canvas>';
            
            fabricCanvas = new fabric.Canvas('fabric-canvas');
            currentFilterIndex = 0; document.getElementById('filter-label').textContent = 'Original';
            let dataUrl = (typeof imageInput === 'string') ? imageInput : imageInput.toDataURL();
            
            fabric.Image.fromURL(dataUrl, function(img) {
                const scale = Math.min(maxWidth / img.width, maxHeight / img.height);
                fabricCanvas.setWidth(img.width * scale); fabricCanvas.setHeight(img.height * scale);
                img.set({ originX: 'center', originY: 'center', left: fabricCanvas.width / 2, top: fabricCanvas.height / 2, scaleX: scale, scaleY: scale, selectable: false, evented: false });
                fabricCanvas.add(img); fabricCanvas.backgroundImage = img; fabricCanvas.renderAll();
                initFabricListeners();
            });
        }
        function rotateDoc(direction) {
            if (!fabricCanvas || !fabricCanvas.backgroundImage) return;
            const img = fabricCanvas.backgroundImage;
            const angle = (direction === 'left' ? -90 : 90);
            img.rotate((img.angle || 0) + angle % 360);
            const container = document.getElementById('view-editor').querySelector('.flex-1');
            const maxWidth = container.clientWidth - 40; const maxHeight = container.clientHeight - 40;
            const isVertical = img.angle % 180 !== 0;
            const effectiveW = isVertical ? img.height : img.width;
            const effectiveH = isVertical ? img.width : img.height;
            const scale = Math.min(maxWidth / effectiveW, maxHeight / effectiveH);
            fabricCanvas.setWidth(effectiveW * scale); fabricCanvas.setHeight(effectiveH * scale);
            img.set({ left: fabricCanvas.width / 2, top: fabricCanvas.height / 2, scaleX: scale, scaleY: scale });
            img.setCoords(); fabricCanvas.renderAll();
        }
        function cycleFilter() {
            if(!fabricCanvas || !fabricCanvas.backgroundImage) return;
            const img = fabricCanvas.backgroundImage;
            const filterModes = ['Original', 'Grayscale', 'Enhanced'];
            currentFilterIndex = (currentFilterIndex + 1) % filterModes.length;
            const mode = filterModes[currentFilterIndex];
            document.getElementById('filter-label').textContent = mode;
            img.filters = [];
            if (mode === 'Grayscale') { img.filters.push(new fabric.Image.filters.Grayscale()); } 
            else if (mode === 'Enhanced') {
                img.filters.push(new fabric.Image.filters.Grayscale());
                img.filters.push(new fabric.Image.filters.Contrast({ contrast: 0.25 }));
                img.filters.push(new fabric.Image.filters.Brightness({ brightness: 0.05 }));
            }
            img.applyFilters(); fabricCanvas.renderAll();
        }
        
        function openAddMenu() { document.getElementById('add-menu-modal').classList.remove('hidden'); document.getElementById('add-menu-modal').classList.add('flex'); }
        function closeAddMenu() { document.getElementById('add-menu-modal').classList.add('hidden'); document.getElementById('add-menu-modal').classList.remove('flex'); }
        function openScannerFromMenu() { closeAddMenu(); openScanner(); }
        function triggerDocUploadFromMenu() { closeAddMenu(); triggerDocUpload(); }
        
        // --- SAVE/OCR ---
        function openSaveModal() {
            document.getElementById('save-modal').classList.remove('hidden');
            document.getElementById('ocr-loading').classList.add('hidden');
            document.getElementById('btn-cancel-save').classList.remove('hidden');
            document.getElementById('btn-confirm-save').classList.remove('hidden');
        }
        function closeSaveModal() { document.getElementById('save-modal').classList.add('hidden'); }

        function parseSmartMetadata(text) {
            const result = { id: null, date: null, amount: null };
            const idMatch = text.match(/(?:no\.|id|#|ref|invoice|order|number)[\s.:]*([a-z0-9\-\/]{3,})/i);
            if (idMatch) result.id = idMatch[1].toUpperCase();
            const dateMatch = text.match(/(\d{1,2}[-/\.]\d{1,2}[-/\.]\d{2,4})/);
            if (dateMatch) result.date = dateMatch[1];
            const amountMatch = text.match(/(?:total|amount|grand total|balance)[\s.:$rm]*([\d,]+\.\d{2})/i);
            if (amountMatch) result.amount = amountMatch[1];
            return result;
        }

        async function confirmSave() {
            const categorySelect = document.getElementById('doc-type-select');
            const category = categorySelect.value;
            const isSigned = document.getElementById('doc-signed-check').checked;
            
            // UI Feedback
            const saveBtn = document.getElementById('btn-confirm-save');
            const originalBtnText = saveBtn.innerHTML;
            saveBtn.innerHTML = 'Saving...';
            saveBtn.disabled = true;

            try {
                // 1. Get Current Image from Canvas
                const finalMultiplier = 2; 
                const currentDataURL = fabricCanvas.toDataURL({ format: 'webp', quality: 0.92, multiplier: finalMultiplier });
                
                // === LOGIC CHANGE FOR PDF VS SCAN ===
                let finalSaveList = [];
                
                if (isPdfBatch) {
                    // PDF Mode: Canvas is Page 1, Queue is Pages 2,3,4...
                    // Order: [Current, ...Queue]
                    finalSaveList = [currentDataURL, ...batchQueue];
                } else {
                    // Scan Mode: Queue is Page 1,2, Canvas is Page 3
                    // Order: [...Queue, Current]
                    finalSaveList = [...batchQueue, currentDataURL];
                }
                
                // 2. Process the List
                const totalPages = finalSaveList.length;
                const baseId = Math.random().toString(36).substr(2, 4).toUpperCase();

                for (let i = 0; i < totalPages; i++) {
                    const dataUrl = finalSaveList[i];
                    
                    let pageSuffix = "";
                    if (totalPages > 1) {
                        pageSuffix = ` (Page ${i + 1})`;
                    }

                    await saveSingleDocument(dataUrl, category, isSigned, baseId, pageSuffix);
                }

                // 3. Cleanup & Close
                isPdfBatch = false;
                batchQueue = []; // Clear queue
                
                // Reset Add Menu Title
                const title = document.querySelector('#add-menu-modal h3');
                if(title) title.textContent = 'Add Document';

                closeSaveModal(); 
                cancelEdit(); 
                editingDocId = null;
                document.getElementById('doc-signed-check').checked = false;

                // Success Message
                if (totalPages > 1) {
                    alert(`âœ… Saved ${totalPages} pages successfully.`);
                }

                // Check Completion
                const job = jobs.find(j => j.id === currentJobId);
                const newStatus = getJobStatus(job);
                if (newStatus === 'Completed') {
                    setTimeout(() => alert("ðŸŽ‰ Job Completed! DO is signed."), 200);
                }

            } catch (err) {
                console.error("Save Error", err);
                alert("Error saving document.");
            } finally {
                saveBtn.innerHTML = originalBtnText;
                saveBtn.disabled = false;
            }
        }

        // --- NEW HELPER FUNCTION TO SAVE INDIVIDUAL DOCS ---
        async function saveSingleDocument(dataURL, category, isSigned, baseId, nameSuffix) {
            let finalDocId, finalDocName;

            // Handle Editing vs New
            if (editingDocId && batchQueue.length === 1) {
                // Single doc edit mode
                finalDocId = editingDocId;
                const job = jobs.find(j => j.id === currentJobId);
                const existingDoc = job.documents.find(d => d.id === editingDocId);
                finalDocName = existingDoc ? existingDoc.name : `${category}_${baseId}.webp`;
            } else {
                // New or Batch
                finalDocId = 'doc_' + Date.now() + '_' + Math.floor(Math.random() * 1000);
                // Clean name construction
                finalDocName = `${category}_${baseId}${nameSuffix}.webp`;
            }

            // Prepare Blob
            const blob = await (await fetch(dataURL)).blob();
            const arrayBuffer = await blob.arrayBuffer();
            const uint8Array = new Uint8Array(arrayBuffer);
            const firestoreBlob = firebase.firestore.Blob.fromUint8Array(uint8Array);
            const sizeMb = (blob.size / (1024*1024)).toFixed(2);
            const sizeStr = sizeMb < 1 ? (blob.size/1024).toFixed(0) + 'KB' : sizeMb + 'MB';

            // Create Metadata
            const newDoc = {
                id: finalDocId, 
                name: finalDocName,
                docCategory: category,
                type: 'scan',
                size: sizeStr,
                date: 'Just Now',
                ocrText: "", 
                smartData: {}, 
                isSigned: isSigned
            };

            // Database Operations
            if (db) {
                const cloudDocMetadata = { ...newDoc };
                delete cloudDocMetadata.src; 
                cloudDocMetadata.hasBinary = true; 
                
                // 1. Upload Binary
                const scanData = { image_blob: firestoreBlob, timestamp: Date.now(), name: finalDocName };
                await db.collection('jobs').doc(currentJobId).collection('scans').doc(finalDocId).set(scanData);

                // 2. Update Job Index
                if (editingDocId && batchQueue.length === 1) {
                    const jobRef = db.collection('jobs').doc(currentJobId);
                    const jobSnap = await jobRef.get();
                    let currentDocs = jobSnap.data().documents;
                    const idx = currentDocs.findIndex(d => d.id === editingDocId);
                    if (idx !== -1) {
                        currentDocs[idx] = cloudDocMetadata; 
                        await jobRef.update({ documents: currentDocs });
                    }
                } else {
                    await db.collection('jobs').doc(currentJobId).update({
                        documents: firebase.firestore.FieldValue.arrayUnion(cloudDocMetadata)
                    });
                }
            } else {
                // Offline Mode
                const job = jobs.find(j => j.id === currentJobId);
                newDoc.src = dataURL;
                if (editingDocId && batchQueue.length === 1) {
                    const idx = job.documents.findIndex(d => d.id === editingDocId);
                    if (idx !== -1) job.documents[idx] = newDoc;
                } else {
                    job.documents.push(newDoc);
                }
                renderJobs(); 
            }
        }
        
        function handleSearch() {
            currentSearchTerm = document.getElementById('job-search').value.toLowerCase();
            renderJobs();
        }

// --- 6. ARCHIVE & EXPORT FUNCTIONS (Add this block) ---

        async function archiveClosedJobs() {
            // 1. Find completed jobs
            const jobsToArchive = jobs.filter(j => getJobStatus(j) === 'Completed');
            if (jobsToArchive.length === 0) return alert("No completed jobs to archive.");

            // 2. Prepare data
            const archiveData = {
                version: 1,
                timestamp: Date.now(),
                jobs: jobsToArchive
            };

            // 3. Create file (CBOR is smaller, JSON is fallback)
            let blob, ext;
            if (typeof CBOR !== 'undefined') {
                blob = new Blob([CBOR.encode(archiveData)], { type: 'application/cbor' });
                ext = 'cbor';
            } else {
                blob = new Blob([JSON.stringify(archiveData)], { type: 'application/json' });
                ext = 'json';
            }

            // 4. Trigger Download
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = `DocuFlow_Archive_${new Date().toISOString().slice(0,10)}.${ext}`;
            document.body.appendChild(a);
            a.click();
            document.body.removeChild(a);
            URL.revokeObjectURL(url);

            // 5. Cleanup Database
            if (confirm(`Successfully downloaded archive of ${jobsToArchive.length} jobs.\n\nDelete them from the active list to free up space?`)) {
                if(db) {
                    const batch = db.batch();
                    jobsToArchive.forEach(job => {
                        const docRef = db.collection('jobs').doc(job.id);
                        batch.delete(docRef);
                    });
                    await batch.commit().catch(e => console.error(e));
                }
                // Update local list instantly
                jobs = jobs.filter(j => getJobStatus(j) !== 'Completed');
                renderJobs();
                updateStorageUI();
            }
        }

        function handleArchiveUpload(input) {
            if (!input.files || !input.files[0]) return;
            const file = input.files[0];
            const reader = new FileReader();
            
            reader.onload = function(e) {
                try {
                    let data;
                    // Detect format based on extension or try both
                    if (file.name.endsWith('.json')) {
                        data = JSON.parse(e.target.result);
                    } else {
                        // Assume CBOR
                        data = CBOR.decode(e.target.result);
                    }
                    
                    if (data && data.jobs) {
                        isViewingArchive = true;
                        archivedJobs = data.jobs;
                        renderJobs();
                        alert(`Loaded Archive: ${data.jobs.length} jobs.`);
                    } else {
                        alert("Invalid archive file.");
                    }
                } catch (err) {
                    console.error(err);
                    alert("Failed to load archive. Make sure it's a valid .cbor or .json file.");
                }
            };
            
            if (file.name.endsWith('.json')) {
                reader.readAsText(file);
            } else {
                reader.readAsArrayBuffer(file);
            }
            input.value = '';
        }

        function downloadJobBundle() {
            if (!currentJobId) return;
            const sourceList = isViewingArchive ? archivedJobs : jobs;
            const job = sourceList.find(j => j.id === currentJobId);
            if (!job || !job.documents.length) return alert("No documents to download.");

            // Use jsPDF
            const { jsPDF } = window.jspdf;
            const doc = new jsPDF();
            
            let y = 10;
            doc.setFontSize(16);
            doc.text(`Job Bundle: ${job.client}`, 10, y);
            y += 10;
            doc.setFontSize(10);
            doc.text(`ID: ${job.id} | Date: ${job.date}`, 10, y);
            y += 10;

            // Simple text list for now, or add images if needed
            job.documents.forEach((d, index) => {
                doc.text(`${index + 1}. ${d.docCategory} - ${d.name}`, 10, y);
                y += 7;
                // Note: Adding actual images to PDF requires loading base64 data which is complex
                // in this simple setup. This acts as a summary sheet.
            });

            doc.save(`${job.client}_Bundle.pdf`);
        }

        async function downloadSinglePDF(docId) {
            // 1. Find Doc
            const sourceList = isViewingArchive ? archivedJobs : jobs;
            const job = sourceList.find(j => j.id === currentJobId);
            const doc = job.documents.find(d => d.id === docId);
            if (!doc) return;

            pendingDownloadDocId = docId;

            // 2. Setup Modal UI
            const modal = document.getElementById('download-modal');
            const img = document.getElementById('download-preview-img');
            const input = document.getElementById('pdf-filename');
            const loader = document.getElementById('preview-loader');

            modal.classList.remove('hidden');
            setTimeout(() => modal.classList.remove('opacity-0'), 10);
            
            // 3. Reset State
            img.classList.add('opacity-0');
            img.src = '';
            loader.classList.remove('hidden');
            
            // 4. PRE-FILL FILENAME (Updated Logic)
            // Use the current document name, stripped of extension
            const cleanName = doc.name.replace(/\.[^/.]+$/, "");
            input.value = cleanName;
            
            // Optional: If name is generic/empty, fallback to Category + Date
            if (!input.value || input.value.startsWith('scan_')) {
                 const dateStr = new Date().toISOString().slice(0,10);
                 input.value = `${doc.docCategory}_${dateStr}`;
            }

            input.select(); 

            // 5. Load Image
            const imgSrc = await ensureDocImageLoaded(job, doc);
            if(imgSrc) {
                img.src = imgSrc;
            } else {
                alert("Error loading image preview.");
                closeDownloadModal();
            }
        }
        function closeDownloadModal() {
            const modal = document.getElementById('download-modal');
            modal.classList.add('opacity-0');
            setTimeout(() => {
                modal.classList.add('hidden');
                document.getElementById('download-preview-img').src = '';
                pendingDownloadDocId = null;
            }, 200);
        }

        async function executePDFDownload() {
            if (!pendingDownloadDocId) return;

            // 1. Get Data
            const sourceList = isViewingArchive ? archivedJobs : jobs;
            const job = sourceList.find(j => j.id === currentJobId);
            const doc = job.documents.find(d => d.id === pendingDownloadDocId);
            const filenameInput = document.getElementById('pdf-filename').value.trim();
            const finalFilename = (filenameInput || "document") + ".pdf";

            // 2. Close Modal & Show Feedback
            closeDownloadModal();
            
            // Optional: Show a toast or small loading indicator here
            
            try {
                // 3. Prepare Image
                const imgSrc = await ensureDocImageLoaded(job, doc);
                const img = new Image();
                img.src = imgSrc;
                await new Promise(r => img.onload = r);

                // 4. Create Clean JPEG
                const canvas = document.createElement('canvas');
                canvas.width = img.width;
                canvas.height = img.height;
                const ctx = canvas.getContext('2d');
                ctx.drawImage(img, 0, 0);
                const cleanDataURL = canvas.toDataURL('image/jpeg', 0.85);

                // 5. Generate PDF
                const { jsPDF } = window.jspdf;
                const isLandscape = img.width > img.height;
                const pdf = new jsPDF({
                    orientation: isLandscape ? 'l' : 'p',
                    unit: 'mm',
                    format: 'a4'
                });

                const pageWidth = pdf.internal.pageSize.getWidth();
                const pageHeight = pdf.internal.pageSize.getHeight();
                const widthRatio = pageWidth / img.width;
                const heightRatio = pageHeight / img.height;
                const ratio = Math.min(widthRatio, heightRatio);
                
                const finalW = img.width * ratio;
                const finalH = img.height * ratio;
                const x = (pageWidth - finalW) / 2;
                const y = (pageHeight - finalH) / 2;

                pdf.addImage(cleanDataURL, 'JPEG', x, y, finalW, finalH);
                pdf.save(finalFilename);

            } catch (err) {
                console.error("PDF Gen Error:", err);
                alert("Failed to generate PDF.");
            }
        }
                // --- INIT CALL ---
        window.onload = () => {
            // Wait for Lucide script to parse
            const initUI = setInterval(() => {
                if(typeof lucide !== 'undefined') {
                    lucide.createIcons();
                    initFirebase(); 
                    setupPasteListener();
                    clearInterval(initUI);
                }
            }, 100);

            // Lazy Load Heavy Libs
            const initHeavyLibs = setInterval(() => {
                if(typeof jscanify !== 'undefined') {
                    scanner = new jscanify();
                    clearInterval(initHeavyLibs);
                }
            }, 500);
        };
        
    </script>
</body>
</html>








