<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>DocuFlowHQ</title>
    <meta name="description" content="Instant document scanner and organizer.">

    <link rel="preconnect" href="https://cdn.tailwindcss.com" crossorigin>
    <link rel="preconnect" href="https://docs.opencv.org" crossorigin>
    <link rel="preconnect" href="https://cdn.jsdelivr.net" crossorigin>
    <link rel="preconnect" href="https://cdnjs.cloudflare.com" crossorigin>
    <link rel="preconnect" href="https://unpkg.com" crossorigin>
    <link rel="preconnect" href="https://www.gstatic.com" crossorigin>

    <script src="https://cdn.tailwindcss.com"></script>
    <script>
        tailwind.config = {
            theme: { extend: { colors: { gray: { 900: '#111827', 800: '#1f2937' } } } }
        }
    </script>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.11.174/pdf.min.js"></script>
    <script>
        // Set the worker source immediately to prevent load errors
        window.pdfjsLib.GlobalWorkerOptions.workerSrc = 'https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.11.174/pdf.worker.min.js';
    </script>

    <style>
        /* Hardware Acceleration for smoother animations */
        .hardware-accel { transform: translate3d(0,0,0); backface-visibility: hidden; }
        
        /* Mobile Optimizations */
        body { -webkit-tap-highlight-color: transparent; overscroll-behavior-y: none; }
        ::-webkit-scrollbar { display: none; }
        
        /* Loading Spinner */
        .loader {
            border: 3px solid #f3f3f3; border-radius: 50%; border-top: 3px solid #10b981;
            width: 20px; height: 20px; animation: spin 1s linear infinite;
        }
        @keyframes spin { 0% { transform: rotate(0deg); } 100% { transform: rotate(360deg); } }
    </style>
</head>
<body class="bg-gray-900 text-white h-screen w-screen overflow-hidden font-sans antialiased selection:bg-emerald-500/30">

    <div id="view-auth" class="fixed inset-0 z-[100] bg-gray-900 flex items-center justify-center p-4">
        <div class="bg-gray-800 w-full max-w-md p-8 rounded-2xl border border-gray-700 shadow-2xl">
            
            <div class="text-center mb-8">
                <div class="w-16 h-16 bg-emerald-500/10 rounded-full flex items-center justify-center mx-auto mb-4 border border-emerald-500/20">
                    <i data-lucide="shield-check" class="w-8 h-8 text-emerald-500"></i>
                </div>
                <h2 id="auth-title" class="text-2xl font-bold text-white">System Login</h2>
                <p id="auth-subtitle" class="text-gray-400 text-sm mt-2">Please sign in to access documents.</p>
            </div>

            <div class="space-y-4">
                <div>
                    <label class="text-xs font-bold text-gray-500 uppercase tracking-wider">Email</label>
                    <input type="email" id="auth-email" class="w-full bg-gray-900 text-white border border-gray-700 rounded-lg p-3 mt-1 focus:border-emerald-500 focus:ring-1 focus:ring-emerald-500 outline-none transition-all" placeholder="user@company.com">
                </div>
                <div>
                    <label class="text-xs font-bold text-gray-500 uppercase tracking-wider">Password</label>
                    <input type="password" id="auth-password" class="w-full bg-gray-900 text-white border border-gray-700 rounded-lg p-3 mt-1 focus:border-emerald-500 focus:ring-1 focus:ring-emerald-500 outline-none transition-all" placeholder="â€¢â€¢â€¢â€¢â€¢â€¢">
                </div>
                
                <button onclick="handleAuthAction()" id="btn-auth-action" class="w-full py-3 bg-emerald-500 hover:bg-emerald-600 text-white font-bold rounded-lg shadow-lg shadow-emerald-500/20 transition-all active:scale-95 flex justify-center items-center gap-2">
                    <span id="btn-auth-text">Sign In</span>
                    <i data-lucide="arrow-right" class="w-4 h-4"></i>
                </button>
            </div>
            
            <div id="auth-loading" class="hidden text-center mt-4">
                <div class="loader mx-auto w-6 h-6 border-2 border-emerald-500 border-t-transparent rounded-full animate-spin"></div>
            </div>
        </div>
    </div>

    <canvas id="processing-canvas" class="hidden"></canvas>
    <input type="file" id="doc-upload-input" accept="image/*,application/pdf" class="hidden" onchange="handleDocUpload(this)">

    <header id="app-header" class="fixed top-0 w-full z-50 bg-gray-900/90 backdrop-blur border-b border-gray-800 p-4 flex justify-between items-center h-16 hardware-accel hidden">
        <div class="flex items-center gap-2">
            <i data-lucide="layers" class="text-emerald-400"></i>
            <h1 class="font-bold text-lg tracking-wide">DocuFlow</h1>
        </div>
        <div class="flex gap-2">
            
            <button id="btn-team-manager" onclick="openInviteModal()" class="hidden text-xs bg-indigo-500/10 text-indigo-400 hover:bg-indigo-500 hover:text-white px-3 py-1.5 rounded-full border border-indigo-500/30 flex items-center gap-1 active:scale-95 transition-all" title="Manage Team">
                <i data-lucide="users" class="w-3 h-3"></i> Team
            </button>
    
            <input type="file" id="archive-upload" accept=".cbor,.json" class="hidden" onchange="handleArchiveUpload(this)">
    
            <button id="btn-archive" onclick="archiveClosedJobs()" class="hidden text-xs bg-yellow-900/20 hover:bg-yellow-900/50 text-yellow-500 px-3 py-1.5 rounded-full border border-yellow-700/50 flex items-center gap-1 active:scale-95 transition-transform">
                <i data-lucide="archive" class="w-3 h-3"></i> Archive
            </button>
            
            <button id="btn-manual-restore" onclick="document.getElementById('archive-upload').click()" class="hidden text-xs bg-gray-800 hover:bg-gray-700 text-gray-400 px-2 py-1.5 rounded-full border border-gray-700 active:scale-95 transition-transform" title="Manual Restore">
                <i data-lucide="upload-cloud" class="w-3 h-3"></i>
            </button>
    
            <button onclick="logout()" class="text-xs bg-red-900/20 hover:bg-red-900/50 text-red-400 px-3 py-1.5 rounded-full border border-red-900/30 flex items-center gap-1 active:scale-95 transition-transform">
                    <i data-lucide="log-out" class="w-3 h-3"></i>
            </button>
        </div>
    </header>

    <main id="view-jobs" class="hidden pt-20 pb-24 px-4 h-full overflow-y-auto relative hardware-accel">
        <div class="bg-gray-800/50 rounded-lg p-3 mb-6 border border-gray-700">
            <div class="flex justify-between items-end mb-2">
                <span class="text-xs text-gray-400 font-medium">Storage Usage</span>
                <span id="storage-text" class="text-xs font-mono text-emerald-400">Calculating...</span>
            </div>
            <div class="h-2 w-full bg-gray-700 rounded-full overflow-hidden">
                <div id="storage-bar" class="h-full bg-emerald-500 w-0 transition-all duration-500"></div>
            </div>
            <div id="archive-alert" class="hidden mt-3 pt-3 border-t border-gray-700/50 flex items-center justify-between">
                <span class="text-xs text-yellow-400 flex items-center gap-1">
                    <i data-lucide="hard-drive" class="w-3 h-3"></i> Cleanup Recommended
                </span>
                <button onclick="archiveClosedJobs()" class="text-xs bg-yellow-900/30 text-yellow-300 px-3 py-1.5 rounded border border-yellow-900/50 hover:bg-yellow-900/50 transition-colors">
                    Archive Completed
                </button>
            </div>
        </div>

        <div class="flex justify-between items-end mb-4">
            <h2 class="text-xl font-semibold text-gray-200">Job List</h2>
            <span id="connection-status" class="text-[10px] text-gray-500 flex items-center gap-1">
                <div class="w-2 h-2 rounded-full bg-red-500"></div> Offline
            </span>
        </div>

        <div class="mb-4 relative">
            <input type="text" id="job-search" placeholder="Search Client, ID, or Content..." 
                   class="w-full bg-gray-800 text-white border border-gray-700 rounded-lg py-3 pl-10 pr-4 focus:border-emerald-500 outline-none text-sm placeholder-gray-500 transition-colors"
                   onkeyup="handleSearch()">
            <i data-lucide="search" class="absolute left-3 top-3.5 text-gray-500 w-4 h-4"></i>
        </div>
        
        <div class="space-y-4 pb-20" id="job-container">
            <div class="animate-pulse space-y-3">
                <div class="h-20 bg-gray-800 rounded-xl border border-gray-700"></div>
                <div class="h-20 bg-gray-800 rounded-xl border border-gray-700"></div>
            </div>
        </div>

        <button onclick="openNewJobModal()" class="fixed bottom-8 right-8 w-14 h-14 bg-emerald-500 rounded-full flex items-center justify-center shadow-lg shadow-emerald-500/20 active:scale-90 transition-transform z-30">
            <i data-lucide="plus" class="text-white w-8 h-8"></i>
        </button>
    </main>

    <div id="view-job-details" class="fixed inset-0 bg-gray-900 z-40 hidden flex flex-col pt-16 hardware-accel">
       <div class="h-16 flex items-center gap-4 px-4 border-b border-gray-800 bg-gray-900/50 backdrop-blur shrink-0">
            <button onclick="closeJobDetails()" class="p-2 -ml-2 text-gray-400 hover:text-white">
                <i data-lucide="arrow-left"></i>
            </button>
            <div class="flex-1 overflow-hidden">
                <div class="flex items-center gap-2">
                    <h2 id="detail-client" class="font-bold text-lg leading-tight text-white truncate max-w-[200px]">Client Name</h2>
                    <button onclick="openRenameJobModal()" class="text-gray-500 hover:text-emerald-400 transition-colors">
                        <i data-lucide="pencil" class="w-4 h-4"></i>
                    </button>
                </div>
                <div class="flex items-center gap-2">
                    <span id="detail-id" class="text-xs font-mono text-emerald-400">#ID</span>
                    <span id="detail-status" class="text-[10px] px-1.5 py-0.5 rounded font-bold uppercase tracking-wider">Status</span>
                    <span id="detail-archive-badge" class="hidden text-[10px] px-1.5 py-0.5 rounded bg-purple-900/50 text-purple-300 border border-purple-800">ARCHIVED</span>
                </div>
            </div>
            
            <div class="flex gap-2">
                <button onclick="promptDelete(currentJobId, 'job')" class="p-2 text-red-400 hover:text-white bg-red-900/20 rounded-full border border-red-900/50 active:scale-95 transition-transform" title="Delete Job">
                    <i data-lucide="trash-2" class="w-5 h-5"></i>
                </button>
                <button onclick="downloadJobBundle()" class="p-2 text-blue-400 hover:text-white bg-blue-900/20 rounded-full border border-blue-900/50 active:scale-95 transition-transform" title="Download PDF">
                    <i data-lucide="file-stack" class="w-5 h-5"></i>
                </button>
            </div>
        </div>
        
        <div class="flex-1 overflow-y-auto p-4 space-y-3" id="document-list"></div>

        <div id="empty-docs" class="hidden absolute inset-0 flex flex-col items-center justify-center text-gray-600 pointer-events-none pt-20">
            <i data-lucide="folder-open" class="w-16 h-16 mb-2 opacity-20"></i>
            <p class="text-sm">No documents yet</p>
        </div>

        <button id="scan-fab" onclick="openAddMenu()" class="absolute bottom-8 right-8 w-14 h-14 bg-emerald-500 rounded-full flex items-center justify-center shadow-lg shadow-emerald-500/20 active:scale-90 transition-transform z-50">
            <i data-lucide="plus" class="text-white w-6 h-6"></i>
        </button>
    </div>

    <div id="add-menu-modal" class="fixed inset-0 z-[80] hidden flex items-end sm:items-center justify-center bg-black/80 backdrop-blur-sm px-4 pb-4 sm:pb-0 transition-opacity duration-200">
        <div class="bg-gray-800 p-6 rounded-2xl w-full max-w-sm border border-gray-700 shadow-2xl flex flex-col gap-3">
            <h3 class="text-lg font-bold text-white mb-2 text-center">Add Document</h3>
            <button onclick="openScannerFromMenu()" class="flex items-center gap-4 p-4 bg-gray-700/50 hover:bg-gray-700 rounded-xl border border-gray-600 transition-colors group">
                <div class="w-12 h-12 rounded-full bg-emerald-900/30 flex items-center justify-center text-emerald-400 group-hover:bg-emerald-500 group-hover:text-white transition-colors"><i data-lucide="camera" class="w-6 h-6"></i></div>
                <div class="text-left"><p class="font-bold text-gray-200">Scan with Camera</p><p class="text-xs text-gray-400">Capture and auto-crop</p></div>
            </button>
            <button onclick="triggerDocUploadFromMenu()" class="flex items-center gap-4 p-4 bg-gray-700/50 hover:bg-gray-700 rounded-xl border border-gray-600 transition-colors group">
                <div class="w-12 h-12 rounded-full bg-blue-900/30 flex items-center justify-center text-blue-400 group-hover:bg-blue-500 group-hover:text-white transition-colors"><i data-lucide="image" class="w-6 h-6"></i></div>
                <div class="text-left"><p class="font-bold text-gray-200">Upload Image or PDF</p><p class="text-xs text-gray-400">From gallery or file system</p></div>
            </button>
            <button onclick="handlePasteClick()" class="flex items-center gap-4 p-4 bg-gray-700/50 hover:bg-gray-700 rounded-xl border border-gray-600 transition-colors group">
                <div class="w-12 h-12 rounded-full bg-purple-900/30 flex items-center justify-center text-purple-400 group-hover:bg-purple-500 group-hover:text-white transition-colors"><i data-lucide="clipboard" class="w-6 h-6"></i></div>
                <div class="text-left"><p class="font-bold text-gray-200">Paste from Clipboard</p><p class="text-xs text-gray-400">Paste copied image (Ctrl+V)</p></div>
            </button>
            <button onclick="closeAddMenu()" class="mt-2 py-3 text-gray-400 font-medium hover:text-white rounded-lg hover:bg-gray-700/50 transition-colors">Cancel</button>
        </div>
    </div>

    <div id="download-modal" class="fixed inset-0 z-[90] hidden flex items-center justify-center bg-black/80 backdrop-blur-sm px-2 md:px-4 opacity-0 transition-opacity duration-200">
        <div class="bg-gray-900 md:bg-gray-800 rounded-2xl w-full max-w-7xl border border-gray-700 shadow-2xl relative overflow-hidden flex flex-col md:flex-row h-[85vh] md:h-[95vh]">
            <div class="absolute inset-0 md:relative md:inset-auto md:w-[70%] bg-black/50 md:bg-gray-900 flex items-center justify-center p-0 md:p-4 z-0">
                <div class="loader absolute text-emerald-500" id="preview-loader"></div>
                <img id="download-preview-img" class="w-full h-full object-contain opacity-0 transition-opacity duration-300" onload="this.classList.remove('opacity-0'); document.getElementById('preview-loader').classList.add('hidden')">
            </div>
            <div class="absolute bottom-0 left-0 right-0 z-10 p-5 bg-gray-900/95 backdrop-blur-xl border-t border-gray-700 rounded-t-2xl md:relative md:inset-auto md:w-[30%] md:bg-gray-800 md:border-t-0 md:border-l md:rounded-none md:flex md:flex-col">
                <div class="flex justify-between items-start mb-4">
                    <h3 class="text-lg md:text-xl font-bold text-white">Export to PDF</h3>
                    <button onclick="closeDownloadModal()" class="text-gray-400 hover:text-white"><i data-lucide="x" class="w-6 h-6"></i></button>
                </div>
                <p class="hidden md:block text-sm text-gray-400 mb-6">Review the document and give it a specific name before exporting.</p>
                <div class="space-y-4 md:mt-auto">
                    <div>
                        <label class="block text-xs font-semibold text-gray-500 uppercase tracking-wider mb-1.5">Filename</label>
                        <div class="relative">
                            <input type="text" id="pdf-filename" class="w-full bg-gray-800 md:bg-gray-900 text-white border border-gray-600 rounded-xl p-3 pr-12 focus:border-emerald-500 outline-none font-mono text-sm" placeholder="e.g. PO_12345">
                            <span class="absolute right-4 top-3.5 text-gray-500 text-sm">.pdf</span>
                        </div>
                    </div>
                    <div class="flex gap-3 pt-2">
                        <button onclick="closeDownloadModal()" class="flex-1 py-3 text-gray-400 font-medium hover:text-white rounded-xl hover:bg-gray-700/50 transition-colors">Cancel</button>
                        <button onclick="executePDFDownload()" class="flex-1 py-3 bg-emerald-500 text-white font-bold rounded-xl shadow-lg shadow-emerald-500/20 active:scale-95 transition-transform flex justify-center items-center gap-2">
                            <span>Download</span> <i data-lucide="download" class="w-4 h-4"></i>
                        </button>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <div id="archive-confirm-modal" class="fixed inset-0 z-[100] hidden flex items-center justify-center bg-black/90 backdrop-blur-sm px-4">
        <div class="bg-gray-800 p-6 rounded-2xl w-full max-w-md border border-yellow-600/50 shadow-2xl flex flex-col gap-4">
            
            <div class="flex items-start gap-4">
                <div class="p-3 bg-yellow-900/30 rounded-full border border-yellow-600/50 text-yellow-500 shrink-0">
                    <i data-lucide="server-off" class="w-6 h-6"></i>
                </div>
                <div>
                    <h3 class="text-lg font-bold text-white">Cold Storage Archive</h3>
                    <p class="text-xs text-gray-400 mt-1">
                        You are about to move <span id="archive-count" class="text-white font-bold">0</span> jobs to offline storage.
                    </p>
                </div>
            </div>
    
            <div class="bg-gray-900/50 p-4 rounded-xl border border-gray-700 text-xs text-gray-400 space-y-2">
                <p>1. Images will be <span class="text-emerald-400 font-bold">DOWNLOADED</span> to your device.</p>
                <p>2. Images will be <span class="text-red-400 font-bold">REMOVED</span> from the cloud.</p>
                <p>3. Metadata remains searchable in the app.</p>
            </div>
    
            <div>
                <label class="block text-[10px] font-bold text-gray-500 uppercase tracking-wider mb-1.5">Backup Filename</label>
                <input type="text" id="archive-filename-input" 
                       class="w-full bg-gray-900 text-white border border-gray-600 rounded-lg p-3 font-mono text-sm focus:border-yellow-500 focus:ring-1 focus:ring-yellow-500 outline-none"
                       placeholder="DocuFlow_Backup.cbor">
            </div>
    
            <div class="flex gap-3 mt-2">
                <button onclick="document.getElementById('archive-confirm-modal').classList.add('hidden')" class="flex-1 py-3 text-gray-400 font-medium hover:text-white rounded-lg hover:bg-gray-700/50 transition-colors">
                    Cancel
                </button>
                <button id="btn-execute-archive" onclick="executeArchive()" class="flex-1 py-3 bg-yellow-600 hover:bg-yellow-500 text-white font-bold rounded-lg shadow-lg shadow-yellow-900/20 active:scale-95 transition-transform flex justify-center items-center gap-2">
                    <span>Download & Wipe</span>
                    <i data-lucide="download" class="w-4 h-4"></i>
                </button>
            </div>
        </div>
    </div>

    <div id="view-scanner" class="fixed inset-0 bg-black z-[60] hidden flex flex-col">
        <div class="relative flex-1 bg-black overflow-hidden flex items-center justify-center">
            <video id="video" class="absolute min-w-full min-h-full object-cover" playsinline autoplay muted></video>
            
            <div class="absolute inset-0 pointer-events-none opacity-30">
                <div class="absolute top-1/3 left-0 w-full h-px bg-white"></div>
                <div class="absolute top-2/3 left-0 w-full h-px bg-white"></div>
                <div class="absolute left-1/3 top-0 w-px h-full bg-white"></div>
                <div class="absolute left-2/3 top-0 w-px h-full bg-white"></div>
            </div>

            <div class="absolute top-8 bg-black/50 px-4 py-2 rounded-full text-sm font-medium text-white backdrop-blur">
                Align document & tap capture
            </div>
        </div>

        <div class="h-32 bg-gray-900 flex items-center justify-around px-8 z-20 border-t border-gray-800 pb-safe-area">
            <button onclick="closeScanner()" class="p-4 rounded-full bg-gray-800 text-gray-400 hover:text-white transition-colors">
                <i data-lucide="x"></i>
            </button>
            
            <button onclick="captureDoc()" class="w-20 h-20 rounded-full border-4 border-white flex items-center justify-center bg-transparent active:scale-90 transition-transform hover:bg-white/10">
                <div class="w-16 h-16 bg-white rounded-full pointer-events-none"></div>
            </button>
            
            <button onclick="triggerDocUpload()" class="p-4 rounded-full bg-gray-800 text-emerald-400 hover:bg-gray-700 transition-colors">
                <i data-lucide="image"></i>
            </button>
        </div>
    </div>

    <div id="view-crop" class="fixed inset-0 bg-black z-[80] hidden flex flex-col">
        <div class="relative flex-1 bg-black overflow-hidden flex items-center justify-center touch-none">
            <img id="crop-img" class="max-w-full max-h-full object-contain pointer-events-none opacity-50">
            <canvas id="crop-overlay" class="absolute inset-0 w-full h-full touch-none"></canvas>
        </div>
        
        <div class="h-20 bg-gray-900 flex items-center justify-between px-6 border-t border-gray-800 shrink-0">
            <button onclick="closeCropView()" class="flex flex-col items-center text-gray-400 hover:text-white">
                <i data-lucide="x" class="w-6 h-6"></i>
                <span class="text-[10px] mt-1 font-medium">Retake</span>
            </button>
            
            <div class="text-white font-bold text-sm tracking-wide">ADJUST CORNERS</div>
            
            <button onclick="applyCrop()" class="flex flex-col items-center text-emerald-400 hover:text-emerald-300">
                <i data-lucide="check" class="w-6 h-6"></i>
                <span class="text-[10px] mt-1 font-bold">Scan</span>
            </button>
        </div>
    </div>

   <div id="view-editor" class="fixed inset-0 bg-gray-900 z-[70] hidden flex flex-col">
    <div class="h-16 flex items-center justify-between px-4 border-b border-gray-700 bg-gray-900/95 backdrop-blur shrink-0 z-10">
        <button onclick="cancelEdit()" class="text-gray-400 hover:text-white px-2">Cancel</button>
        <div class="flex items-center gap-2">
            <button onclick="handleAddPage()" class="flex items-center gap-1 bg-gray-800 hover:bg-gray-700 text-blue-400 px-3 py-1.5 rounded-lg border border-blue-500/30 text-xs font-bold active:scale-95 transition-all">
                <i data-lucide="plus-square" class="w-4 h-4"></i>
                <span>Page</span>
            </button>
            <button id="editor-save-btn" onclick="openSaveModal()" class="bg-emerald-600 hover:bg-emerald-500 text-white px-4 py-1.5 rounded-lg text-xs font-bold shadow-lg shadow-emerald-900/20 active:scale-95 transition-all">
                Save
            </button>
        </div>
    </div>

    <div id="editor-zoom-controls" class="absolute top-20 right-4 flex flex-col gap-2 bg-gray-900/90 backdrop-blur p-2 rounded-xl border border-gray-700 shadow-2xl z-40">
        <button onclick="adjustEditorZoom(0.1)" class="p-2 text-gray-400 hover:text-emerald-400 hover:bg-gray-700 rounded-lg transition-colors"><i data-lucide="plus" class="w-5 h-5"></i></button>
        <span id="editor-zoom-display" class="text-[10px] font-mono text-center text-white py-1">100%</span>
        <button onclick="adjustEditorZoom(-0.1)" class="p-2 text-gray-400 hover:text-red-400 hover:bg-gray-700 rounded-lg transition-colors"><i data-lucide="minus" class="w-5 h-5"></i></button>
        <button onclick="resetEditorZoom()" class="mt-1 p-1 text-[9px] font-bold text-gray-500 hover:text-white uppercase tracking-wider">Fit</button>
    </div>

    <div class="flex-1 bg-gray-800 relative overflow-hidden flex items-center justify-center p-6 bg-[radial-gradient(#374151_1px,transparent_1px)] [background-size:16px_16px] canvas-container">
        <div id="canvas-wrapper" class="shadow-2xl border border-gray-600/50"><canvas id="fabric-canvas"></canvas></div>
    </div>

    <div id="editor-toolbar" class="bg-gray-900 border-t border-gray-700 pb-safe-area">
        <input type="file" id="stamp-input" accept="image/*" class="hidden" onchange="processStampUpload(this)">
        <div class="h-24 flex items-center justify-around px-4">
            <button onclick="rotateDoc('left')" class="flex flex-col items-center gap-1.5 group w-14">
                <div class="w-10 h-10 rounded-full bg-gray-800 border border-gray-700 flex items-center justify-center group-active:scale-90 transition-all text-gray-300 group-hover:text-white group-hover:border-gray-500"><i data-lucide="rotate-ccw" class="w-5 h-5"></i></div>
                <span class="text-[10px] text-gray-400 font-medium">Left</span>
            </button>
            
            <button onclick="rotateDoc('right')" class="flex flex-col items-center gap-1.5 group w-14">
                <div class="w-10 h-10 rounded-full bg-gray-800 border border-gray-700 flex items-center justify-center group-active:scale-90 transition-all text-gray-300 group-hover:text-white group-hover:border-gray-500"><i data-lucide="rotate-cw" class="w-5 h-5"></i></div>
                <span class="text-[10px] text-gray-400 font-medium">Right</span>
            </button>
            
            <div class="h-8 w-px bg-gray-700 mx-1"></div>

            <div id="stamp-options-menu" class="hidden absolute bottom-24 left-1/2 -translate-x-1/2 bg-gray-800 border border-gray-700 rounded-xl shadow-xl p-2 flex flex-col gap-2 w-48 z-50">
                <button onclick="triggerStampCamera(); toggleStampMenu()" class="flex items-center gap-3 px-4 py-3 text-sm text-gray-200 hover:bg-gray-700 rounded-lg transition-colors text-left group">
                    <div class="p-1.5 rounded-full bg-emerald-900/30 text-emerald-400 group-hover:bg-emerald-500 group-hover:text-white transition-colors">
                        <i data-lucide="camera" class="w-4 h-4"></i>
                    </div>
                    <span>Camera</span>
                </button>
                
                <button onclick="triggerStampInput(); toggleStampMenu()" class="flex items-center gap-3 px-4 py-3 text-sm text-gray-200 hover:bg-gray-700 rounded-lg transition-colors text-left group">
                    <div class="p-1.5 rounded-full bg-blue-900/30 text-blue-400 group-hover:bg-blue-500 group-hover:text-white transition-colors">
                        <i data-lucide="image-plus" class="w-4 h-4"></i>
                    </div>
                    <span>Upload Image</span>
                </button>
                
                <button onclick="handlePasteButton(); toggleStampMenu()" class="flex items-center gap-3 px-4 py-3 text-sm text-gray-200 hover:bg-gray-700 rounded-lg transition-colors text-left group">
                    <div class="p-1.5 rounded-full bg-purple-900/30 text-purple-400 group-hover:bg-purple-500 group-hover:text-white transition-colors">
                        <i data-lucide="clipboard-paste" class="w-4 h-4"></i>
                    </div>
                    <span>Paste</span>
                </button>
                
                <div class="absolute -bottom-2 left-1/2 -translate-x-1/2 w-4 h-4 bg-gray-800 border-r border-b border-gray-700 rotate-45"></div>
            </div>
            
            <button onclick="toggleStampMenu()" class="relative flex flex-col items-center gap-1.5 group w-14">
                <div class="w-10 h-10 rounded-full bg-blue-900/30 border border-blue-500/50 flex items-center justify-center group-active:scale-90 transition-all text-blue-400">
                    <i data-lucide="stamp" class="w-5 h-5"></i>
                </div>
                <span class="text-[10px] text-blue-400 font-medium">Stamp</span>
            </button>

            <button onclick="addTextToCanvas()" class="flex flex-col items-center gap-1.5 group w-14">
                <div class="w-10 h-10 rounded-full bg-red-900/30 border border-red-500/50 flex items-center justify-center group-active:scale-90 transition-all text-red-400"><i data-lucide="type" class="w-5 h-5"></i></div>
                <span class="text-[10px] text-red-400 font-medium">Text</span>
            </button>
        </div>
    </div>
    
    <div id="stamp-slider-container" class="hidden absolute bottom-36 left-1/2 -translate-x-1/2 w-72 bg-gray-900/95 backdrop-blur-xl p-4 rounded-2xl border border-gray-700/50 shadow-2xl z-[75] flex flex-col gap-3 transition-all duration-200">
        <div class="flex justify-between items-center border-b border-gray-700/50 pb-2">
            <span class="text-xs font-bold text-gray-200 uppercase tracking-wider flex items-center gap-2">
                <i data-lucide="sliders-horizontal" class="w-3 h-3 text-emerald-400"></i>
                Stamp Cleanup
            </span>
            
            <div class="flex items-center gap-2">
                <span id="slider-value-display" class="text-[10px] font-mono text-emerald-400 bg-emerald-900/30 px-1.5 py-0.5 rounded border border-emerald-900/50">150</span>
                <button onclick="deleteSelectedStamp()" class="p-1.5 bg-red-900/30 hover:bg-red-500 text-red-400 hover:text-white rounded-md border border-red-900/50 transition-colors" title="Remove Stamp">
                    <i data-lucide="trash-2" class="w-3.5 h-3.5"></i>
                </button>
            </div>
        </div>
        
        <div class="relative w-full py-1">
            <input type="range" id="stamp-threshold" min="1" max="255" value="150" 
                   class="w-full h-1.5 bg-gray-700 rounded-full appearance-none cursor-pointer accent-emerald-500 hover:accent-emerald-400 transition-all focus:outline-none focus:ring-2 focus:ring-emerald-500/30"
                   oninput="updateStampThreshold(this.value); document.getElementById('slider-value-display').innerText = this.value">
        </div>
        
        <div class="flex justify-between text-[10px] font-medium text-gray-500 uppercase tracking-tight">
            <span class="flex items-center gap-1"><i data-lucide="minus" class="w-3 h-3"></i> Keep Detail</span>
            <span class="flex items-center gap-1">Remove Background <i data-lucide="plus" class="w-3 h-3"></i></span>
        </div>
    </div>
</div>

    <div id="new-job-modal" class="fixed inset-0 z-[80] hidden flex items-center justify-center bg-black/80 backdrop-blur-sm px-4">
        <div class="bg-gray-800 p-6 rounded-2xl w-full max-w-sm border border-gray-700 shadow-2xl">
            <h3 class="text-lg font-bold text-white mb-4">Create New Job</h3>
            <label class="block text-xs font-semibold text-gray-500 uppercase tracking-wider mb-2">Client / Job Title</label>
            <input type="text" id="new-job-title" placeholder="e.g. Site Visit - Building A" class="w-full bg-gray-900 text-white border border-gray-700 rounded-lg p-3 mb-6 focus:border-emerald-500 outline-none">
            <div class="flex gap-3">
                <button onclick="closeNewJobModal()" class="flex-1 py-3 text-gray-400 font-medium hover:text-white rounded-lg hover:bg-gray-700/50 transition-colors">Cancel</button>
                <button onclick="confirmNewJob()" class="flex-1 py-3 bg-emerald-500 text-white font-bold rounded-lg shadow-lg shadow-emerald-500/20 active:scale-95 transition-transform">Create</button>
            </div>
        </div>
    </div>

    <div id="invite-modal" class="fixed inset-0 z-[90] hidden flex items-center justify-center bg-black/80 backdrop-blur-sm px-4">
        <div class="bg-gray-800 p-6 rounded-2xl w-full max-w-md border border-gray-700 shadow-2xl flex flex-col max-h-[85vh]">
            <div class="flex justify-between items-center mb-4">
                <h3 class="text-lg font-bold text-white">Team Management</h3>
                <button onclick="closeInviteModal()" class="text-gray-400 hover:text-white"><i data-lucide="x" class="w-5 h-5"></i></button>
            </div>
    
            <div class="flex border-b border-gray-700 mb-4">
                <button onclick="switchTeamTab('invites')" id="tab-invites" class="flex-1 py-2 text-sm font-bold text-emerald-400 border-b-2 border-emerald-400">Invites</button>
                <button onclick="switchTeamTab('members')" id="tab-members" class="flex-1 py-2 text-sm font-bold text-gray-500 hover:text-white">Members</button>
            </div>
    
            <div id="view-invites-list" class="flex-1 overflow-y-auto flex flex-col">
                <button onclick="generateNewInvite()" class="w-full py-3 bg-emerald-500 hover:bg-emerald-600 text-white font-bold rounded-xl shadow-lg shadow-emerald-500/20 active:scale-95 transition-all flex justify-center items-center gap-2 mb-4 shrink-0">
                    <i data-lucide="plus" class="w-4 h-4"></i> Generate Link
                </button>
                <div id="invite-list-container" class="space-y-3"></div>
            </div>
    
            <div id="view-members-list" class="hidden flex-1 overflow-y-auto space-y-3">
                </div>
        </div>
    </div>

    <div id="save-modal" class="fixed inset-0 z-[80] hidden flex items-center justify-center bg-black/80 backdrop-blur-sm px-4">
        <div class="bg-gray-800 p-6 rounded-2xl w-full max-w-sm border border-gray-700 shadow-2xl">
            <h3 class="text-lg font-bold text-white mb-1">Save Document</h3>
            <p class="text-xs text-gray-400 mb-6">Confirm details before saving.</p>

            <div class="mb-4 flex items-center gap-3 p-3 bg-gray-900/50 rounded-lg border border-gray-700">
                <input type="checkbox" id="require-sign-checkbox" class="w-5 h-5 rounded border-gray-600 text-emerald-500 focus:ring-emerald-500 bg-gray-800">
                <label for="require-sign-checkbox" class="text-sm text-gray-300 font-medium select-none cursor-pointer">
                    Require Approval
                </label>
            </div>

            <div id="approver-sign-container" class="hidden mb-6 p-3 bg-emerald-900/20 border border-emerald-500/30 rounded-lg transition-all">
                <div class="flex items-center gap-3">
                    <input type="checkbox" id="mark-signed-checkbox" class="w-5 h-5 rounded border-emerald-500 text-emerald-500 focus:ring-emerald-500 bg-gray-800">
                    <label for="mark-signed-checkbox" class="text-sm text-emerald-100 font-bold select-none cursor-pointer flex items-center gap-2">
                        <i data-lucide="pen-tool" class="w-4 h-4"></i> Mark as Approved
                    </label>
                </div>
                <p class="text-[10px] text-emerald-400/80 mt-1 pl-8 leading-tight">
                    Since you are an Approver, you can verify this document immediately.
                </p>
            </div>
            
            <label class="block text-xs font-semibold text-gray-500 uppercase tracking-wider mb-2">Category</label>
            <div class="relative mb-8">
                <select id="doc-type-select" class="w-full bg-gray-900 text-white border border-gray-700 rounded-lg p-3 pr-10 focus:border-emerald-500 outline-none appearance-none">
                    <option value="Quotation">Quotation</option>
                    <option value="Purchase Request">Purchase Request</option>
                    <option value="Purchase Order">Purchase Order </option>
                    <option value="Service Report">Service Report</option>
                    <option value="Delivery Order">Delivery Order ðŸŒŸ</option>
                    <option value="Invoice">Invoice</option>
                    <option value="Permit to Work">Permit to Work</option>
                    <option value="Other">Other</option>
                </select>
                <i data-lucide="chevron-down" class="absolute right-3 top-3.5 text-gray-400 w-5 h-5 pointer-events-none"></i>
            </div>
            
            <div id="ocr-loading" class="hidden text-center mb-4"><div class="loader mx-auto"></div><span class="text-xs text-gray-400 mt-2 block">Reading text...</span></div>
            
            <div class="flex gap-3">
                <button id="btn-cancel-save" onclick="closeSaveModal()" class="flex-1 py-3 text-gray-400 font-medium hover:text-white rounded-lg hover:bg-gray-700/50 transition-colors">Cancel</button>
                <button id="btn-confirm-save" onclick="confirmSave()" class="flex-1 py-3 bg-emerald-500 text-white font-bold rounded-lg shadow-lg shadow-emerald-500/20 active:scale-95 transition-transform flex justify-center items-center gap-2"><span>Save</span><i data-lucide="check" class="w-4 h-4"></i></button>
            </div>
        </div>
    </div>
    
    <div id="delete-modal" class="fixed inset-0 z-[100] hidden flex items-center justify-center bg-black/90 backdrop-blur-sm px-4 opacity-0 transition-opacity duration-200">
        <div class="bg-gray-800 p-6 rounded-2xl w-full max-w-xs border border-red-900/50 shadow-2xl flex flex-col gap-4">
            <div class="flex flex-col items-center text-center">
                <div class="w-12 h-12 rounded-full bg-red-900/30 flex items-center justify-center mb-3">
                    <i data-lucide="trash-2" class="w-6 h-6 text-red-500"></i>
                </div>
                <h3 id="delete-modal-title" class="text-lg font-bold text-white">Delete Item?</h3>
                <p class="text-xs text-gray-400 mt-1">This action cannot be undone.</p>
            </div>

            <div class="bg-gray-900/50 p-3 rounded-lg border border-red-500/20">
                <label class="block text-[10px] text-gray-500 uppercase tracking-wider font-bold mb-1.5 text-center">Type "<span class="text-red-400 select-all">delete</span>" to confirm</label>
                <input type="text" id="delete-confirmation-input" 
                       class="w-full bg-gray-800 text-white text-center font-bold border border-gray-600 rounded-lg p-2 focus:border-red-500 focus:ring-1 focus:ring-red-500 outline-none transition-all uppercase placeholder-gray-600"
                       placeholder="DELETE"
                       oninput="validateDeleteInput(this)">
            </div>

            <div class="flex gap-3 mt-1">
                <button onclick="closeDeleteModal()" class="flex-1 py-3 text-gray-400 font-medium hover:text-white rounded-xl hover:bg-gray-700 transition-colors">Cancel</button>
                <button id="btn-confirm-delete" onclick="executeDelete()" disabled class="flex-1 py-3 bg-gray-700 text-gray-500 font-bold rounded-xl transition-all cursor-not-allowed flex justify-center items-center gap-2">
                    <span>Delete</span>
                </button>
            </div>
        </div>
    </div>

    <div id="view-lightbox" class="fixed inset-0 z-[90] hidden bg-black/95 backdrop-blur flex flex-col items-center justify-center transition-opacity touch-none">
    <div class="absolute top-0 left-0 right-0 p-4 pt-6 bg-gradient-to-b from-black/90 to-transparent z-20 flex justify-between items-start pointer-events-none">
        <div class="flex-1 max-w-md pointer-events-auto">
            <label class="text-[10px] uppercase text-gray-500 font-bold tracking-wider ml-1">Document Name</label>
            <div class="flex items-center gap-2">
                <input type="text" id="lightbox-filename" 
                       class="bg-transparent text-white text-lg font-bold border-b border-gray-700 focus:border-emerald-500 focus:bg-gray-900/50 outline-none w-full py-1 transition-colors" 
                       placeholder="Document Name"
                       onchange="saveDocumentRename()"> <span class="text-gray-600 text-sm font-mono pt-1 select-none">.webp</span>
            </div>
            <p id="rename-feedback" class="text-[10px] text-emerald-500 h-4 opacity-0 transition-opacity font-medium mt-1">Saved!</p>
        </div>
        <button onclick="closeLightbox()" class="text-gray-400 hover:text-white p-2 bg-black/20 rounded-full backdrop-blur pointer-events-auto ml-4">
            <i data-lucide="x" class="w-6 h-6"></i>
        </button>
    </div>

    <div id="lightbox-container" class="flex-1 w-full h-full flex items-center justify-center overflow-hidden relative cursor-move p-4">
         <img id="lightbox-img" 
              draggable="false"
              class="max-w-full max-h-full object-contain transition-transform duration-75 will-change-transform select-none" 
              src="" 
              style="transform: scale(1) translate(0px, 0px);">
    </div>

    <div class="absolute bottom-24 flex items-center gap-4 bg-gray-900/90 backdrop-blur px-4 py-2 rounded-full border border-gray-700 z-30 shadow-2xl">
        <button onclick="updateLightboxZoom(-0.2)" class="p-2 text-gray-400 hover:text-white hover:bg-gray-700 rounded-full transition-colors"><i data-lucide="minus" class="w-5 h-5"></i></button>
        <span id="lightbox-zoom-display" class="text-xs font-mono text-emerald-400 w-12 text-center select-none">100%</span>
        <button onclick="updateLightboxZoom(0.2)" class="p-2 text-gray-400 hover:text-white hover:bg-gray-700 rounded-full transition-colors"><i data-lucide="plus" class="w-5 h-5"></i></button>
        <div class="w-px h-4 bg-gray-700 mx-1"></div>
        <button onclick="resetLightboxZoom()" class="text-[10px] uppercase font-bold text-gray-500 hover:text-white transition-colors">Reset</button>
    </div>

    <div class="absolute bottom-8 flex items-center gap-6 z-20">
        <button onclick="closeLightbox()" class="px-6 py-3 bg-gray-800/80 backdrop-blur rounded-xl text-white border border-gray-700 font-medium active:scale-95 transition-transform shadow-lg shadow-black/50 hover:bg-gray-700">Close</button>
        <button id="lightbox-edit-btn" class="p-4 bg-emerald-500 rounded-full text-white shadow-xl shadow-emerald-500/30 active:scale-90 transition-all hover:bg-emerald-400 border-4 border-gray-900/50"><i data-lucide="pen-tool" class="w-6 h-6"></i></button>
    </div>
</div>

    <div id="rename-job-modal" class="fixed inset-0 z-[100] hidden flex items-center justify-center bg-black/80 backdrop-blur-sm px-4">
        <div class="bg-gray-800 p-6 rounded-2xl w-full max-w-sm border border-gray-700 shadow-2xl">
            <h3 class="text-lg font-bold text-white mb-4">Rename Job</h3>
            <label class="block text-xs font-semibold text-gray-500 uppercase tracking-wider mb-2">New Job Title</label>
            <input type="text" id="rename-job-input" class="w-full bg-gray-900 text-white border border-gray-700 rounded-lg p-3 mb-6 focus:border-emerald-500 outline-none" placeholder="e.g. Project Alpha">
            
            <div class="flex gap-3">
                <button onclick="document.getElementById('rename-job-modal').classList.add('hidden')" class="flex-1 py-3 text-gray-400 font-medium hover:text-white rounded-lg hover:bg-gray-700/50 transition-colors">Cancel</button>
                <button onclick="confirmJobRename()" class="flex-1 py-3 bg-emerald-500 text-white font-bold rounded-lg shadow-lg shadow-emerald-500/20 active:scale-95 transition-transform">Save</button>
            </div>
        </div>
    </div>

    <script src="https://docs.opencv.org/4.10.0/opencv.js" defer></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/fabric.js/5.3.1/fabric.min.js" defer></script>
    <script src="https://cdn.jsdelivr.net/npm/cbor-js@0.1.0/cbor.min.js" defer></script>
    <script src="https://unpkg.com/lucide@latest"></script>
    <script src="https://cdn.jsdelivr.net/npm/tesseract.js@5/dist/tesseract.min.js" defer></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jspdf/2.5.1/jspdf.umd.min.js" defer></script>

    <script src="https://www.gstatic.com/firebasejs/10.7.1/firebase-app-compat.js" defer></script>
    <script src="https://www.gstatic.com/firebasejs/10.7.1/firebase-firestore-compat.js" defer></script>
    <script src="https://www.gstatic.com/firebasejs/10.7.1/firebase-auth-compat.js" defer></script>

    <script>
        // CONFIG
        const firebaseConfig = {
            apiKey: "AIzaSyAOEhir1NRj8LdnFfx1rQwu4fE82VBfd98",
            authDomain: "docuflowhq.firebaseapp.com",
            projectId: "docuflowhq",
            storageBucket: "docuflowhq.firebasestorage.app",
            messagingSenderId: "1091273480971",
            appId: "1:1091273480971:web:bcc5602a409ed3371fa00e"
        };
        const STORAGE_LIMIT_MB = 900; 

        // STATE
        let db = null;
        let storage = null;
        let auth = null;
        let jobs = []; 
        let archivedJobs = [];
        let isViewingArchive = false;
        let currentJobId = null;
        let scanner = null; // Unused now, but kept for legacy ref checks
        let stream = null;
        let fabricCanvas = null;
        let isScanning = false;
        let currentSearchTerm = "";
        let editingDocId = null;
        let pendingDownloadDocId = null; 
        let viewingDocId = null; 
        let batchQueue = []; 
        let isPdfBatch = false; 
        let pendingDeleteType = 'doc'; // 'doc' or 'job'
        let isStampMode = false;
        let activeInviteCode = null; // Stores the validated code for the guest

        let currentUser = null;
        let userRole = 'user'; // 'admin' or 'user'
        
        async function initAuthSystem() {
            // 1. SAFETY CHECK: Is the database ready?
            if (!db) {
                console.log("â³ Database not ready. Retrying in 500ms...");
                setTimeout(initAuthSystem, 500); // Retry after 0.5 seconds
                return;
            }
        
            // 2. Hide Main App, Show Auth Screen
            document.getElementById('view-auth').classList.remove('hidden');
            const mainAppHeader = document.getElementById('app-header');
            const mainAppView = document.getElementById('view-jobs');
            
            if(mainAppHeader) mainAppHeader.classList.add('hidden');
            if(mainAppView) mainAppView.classList.add('hidden');
        
            // 3. Listen for Auth Changes
            firebase.auth().onAuthStateChanged(async (user) => {
                if (user) {
                    // --- USER IS LOGGED IN ---
                    currentUser = user;
                    await loadUserProfile(user.uid);
                    enterApp();
                } else {
                    // --- NO USER ---
                    // Check if system is fresh (0 users)
                    checkSystemStatus();
                }
            });
        }
        
        async function checkSystemStatus() {
            const title = document.getElementById('auth-title');
            const subtitle = document.getElementById('auth-subtitle');
            const btnText = document.getElementById('btn-auth-text');
            const authBtn = document.getElementById('btn-auth-action');
        
            // 1. CHECK URL FOR INVITE CODE
            const urlParams = new URLSearchParams(window.location.search);
            const inviteId = urlParams.get('invite');
        
            if (inviteId) {
                // Validate the invite against Firestore
                btnText.innerText = "Verifying Invite...";
                authBtn.disabled = true;
        
                try {
                    const doc = await db.collection('invites').doc(inviteId).get();
                    
                    if (doc.exists && doc.data().status === 'active') {
                        // VALID INVITE
                        activeInviteCode = inviteId; // Save for later
                        
                        title.innerText = "You're Invited!";
                        subtitle.innerText = "Create your account to join the team.";
                        btnText.innerText = "Create Account";
                        authBtn.setAttribute('data-mode', 'signup');
                        authBtn.disabled = false;
                        
                        // Optional: Show "Back to Login" link if needed
                        return; 
                    } else {
                        // INVALID INVITE
                        title.innerText = "Invalid Link";
                        subtitle.innerHTML = "<span class='text-red-400'>This invite is expired or revoked.</span>";
                        btnText.innerText = "Return to Login";
                        authBtn.setAttribute('data-mode', 'reset-url'); // Custom mode to clear URL
                        authBtn.disabled = false;
                        return;
                    }
                } catch (e) {
                    console.error("Invite check failed", e);
                    // Fallback to normal login if check crashes
                }
            }
        
            // 2. NORMAL FLOW (No Invite in URL)
            try {
                const usersSnap = await db.collection('users').limit(1).get();
                
                if (usersSnap.empty) {
                    // ZERO USERS -> ADMIN SETUP
                    title.innerText = "System Setup";
                    subtitle.innerText = "No users detected. Create Admin account.";
                    btnText.innerText = "Register Admin";
                    authBtn.setAttribute('data-mode', 'register-admin');
                } else {
                    // NORMAL LOGIN
                    title.innerText = "System Login";
                    subtitle.innerText = "Please sign in to continue.";
                    btnText.innerText = "Sign In";
                    authBtn.setAttribute('data-mode', 'login');
                }
            } catch (err) {
                console.error("System Check Error:", err);
                title.innerText = "System Login"; 
            }
        }
        
        async function handleAuthAction() {
            const email = document.getElementById('auth-email').value;
            const password = document.getElementById('auth-password').value;
            const btn = document.getElementById('btn-auth-action');
            const mode = btn.getAttribute('data-mode');
        
            // Handle "Reset URL" (Invalid Invite Button)
            if (mode === 'reset-url') {
                window.history.replaceState({}, document.title, "/");
                window.location.reload();
                return;
            }
        
            if (!email || !password) return alert("Please fill in all fields");
            if (password.length < 6) return alert("Password must be at least 6 characters");
        
            document.getElementById('btn-auth-text').innerText = "Processing...";
            document.getElementById('auth-loading').classList.remove('hidden');
        
            try {
                if (mode === 'login') {
                    await firebase.auth().signInWithEmailAndPassword(email, password);
                } 
                else if (mode === 'register-admin' || mode === 'signup') {
                    // --- REGISTRATION ---
                    const userCred = await firebase.auth().createUserWithEmailAndPassword(email, password);
                    const role = (mode === 'register-admin') ? 'admin' : 'user';
        
                    // 1. Create User Profile
                    await db.collection('users').doc(userCred.user.uid).set({
                        email: email,
                        role: role,
                        createdAt: new Date().toISOString()
                    });
        
                    // 2. IF INVITE WAS USED, MARK IT AS USED
                    if (mode === 'signup' && activeInviteCode) {
                        await db.collection('invites').doc(activeInviteCode).update({
                            status: 'used',
                            usedBy: userCred.user.uid,
                            usedByEmail: email,
                            usedAt: new Date().toISOString()
                        });
                    }
        
                    alert(role === 'admin' ? "Admin Account Created!" : "Welcome to the Team!");
                    
                    // Clean URL
                    if (activeInviteCode) window.history.replaceState({}, document.title, "/");
                }
            } catch (err) {
                console.error(err);
                alert("Error: " + err.message);
                document.getElementById('btn-auth-text').innerText = (mode === 'login' ? "Sign In" : "Register");
                document.getElementById('auth-loading').classList.add('hidden');
            }
        }
        
        // Global Flags
        let userIsApprover = false;
        
        async function loadUserProfile(uid) {
            const doc = await db.collection('users').doc(uid).get();
            if (doc.exists) {
                const data = doc.data();
                
                // 1. Role (Admin vs User) - Controls archiving, team invite, delete jobs
                userRole = data.role; 
                
                // 2. Approver Status - Controls signing documents
                // We strictly look at the database flag. Admin does NOT imply Approver anymore.
                userIsApprover = data.isApprover === true; 
                
                console.log(`ðŸ‘¤ User Loaded: Role=[${userRole}], Approver=[${userIsApprover}]`);
            }
        }

        // --- TEAM MANAGEMENT LOGIC ---

        function switchTeamTab(tab) {
            const invitesView = document.getElementById('view-invites-list');
            const membersView = document.getElementById('view-members-list');
            const tabInvites = document.getElementById('tab-invites');
            const tabMembers = document.getElementById('tab-members');
        
            if (tab === 'invites') {
                invitesView.classList.remove('hidden');
                membersView.classList.add('hidden');
                tabInvites.className = "flex-1 py-2 text-sm font-bold text-emerald-400 border-b-2 border-emerald-400";
                tabMembers.className = "flex-1 py-2 text-sm font-bold text-gray-500 hover:text-white";
                loadInvites();
            } else {
                invitesView.classList.add('hidden');
                membersView.classList.remove('hidden');
                tabInvites.className = "flex-1 py-2 text-sm font-bold text-gray-500 hover:text-white";
                tabMembers.className = "flex-1 py-2 text-sm font-bold text-emerald-400 border-b-2 border-emerald-400";
                loadTeamMembers();
            }
        }
        
        async function loadTeamMembers() {
            const container = document.getElementById('view-members-list');
            container.innerHTML = '<div class="loader mx-auto mt-4"></div>';
        
            try {
                const snapshot = await db.collection('users').orderBy('createdAt', 'desc').get();
                
                if (snapshot.empty) {
                    container.innerHTML = '<div class="text-center text-gray-500 text-sm mt-4">No members found.</div>';
                    return;
                }
        
                // Check if the person LOOKING at the list is an Admin
                // (We use the global userRole variable set during login)
                const amIAdmin = (userRole === 'admin');
        
                container.innerHTML = snapshot.docs.map(doc => {
                    const user = doc.data();
                    const isMe = (currentUser && currentUser.uid === doc.id);
                    const targetIsAdmin = user.role === 'admin';
                    
                    // 1. CHECKBOX STATUS
                    // STRICTLY respect the database flag. 
                    // Being an Admin does NOT automatically make you an approver anymore.
                    const isApprover = user.isApprover === true; 
                    const checked = isApprover ? 'checked' : '';
        
                    // 2. DISABLE LOGIC
                    // If I am an Admin, I can edit ANYONE (myself, other admins, users).
                    // If I am not an Admin, I can't edit anyone.
                    const disabled = amIAdmin ? 'cursor-pointer' : 'disabled opacity-50 cursor-not-allowed';
                    
                    // Badge Logic
                    let roleBadge = `<span class="text-[10px] bg-gray-700 text-gray-300 px-1.5 py-0.5 rounded">User</span>`;
                    if (targetIsAdmin) roleBadge = `<span class="text-[10px] bg-purple-900/50 text-purple-300 border border-purple-700 px-1.5 py-0.5 rounded">Admin</span>`;
        
                    return `
                    <div class="bg-gray-900/50 p-3 rounded-xl border border-gray-700 flex justify-between items-center">
                        <div class="overflow-hidden">
                            <div class="font-bold text-sm text-white truncate w-40">${user.email}</div>
                            <div class="flex items-center gap-2 mt-1">
                                ${roleBadge}
                                ${isMe ? '<span class="text-[10px] text-emerald-500">(You)</span>' : ''}
                            </div>
                        </div>
                        
                        <div class="flex items-center gap-2 bg-gray-800 p-2 rounded-lg border border-gray-600">
                            <input type="checkbox" id="check-${doc.id}" ${checked} ${disabled} 
                                   onchange="toggleUserApprover('${doc.id}', this)"
                                   class="w-4 h-4 rounded border-gray-500 text-emerald-500 focus:ring-emerald-500 bg-gray-700 ${disabled}">
                            <label for="check-${doc.id}" class="text-[10px] font-bold text-gray-400 uppercase select-none ${disabled}">
                                Approver
                            </label>
                        </div>
                    </div>`;
                }).join('');
        
            } catch (e) {
                console.error(e);
                container.innerHTML = '<div class="text-red-400 text-center text-sm">Error loading members</div>';
            }
        }
        
        async function toggleUserApprover(targetUid, checkbox) {
            // Optimistic UI update is handled by the browser checkbox itself
            
            const isApprover = checkbox.checked;
            
            try {
                await db.collection('users').doc(targetUid).update({
                    isApprover: isApprover
                });
                console.log(`User ${targetUid} approver status: ${isApprover}`);
            } catch (e) {
                console.error("Failed to update role", e);
                checkbox.checked = !isApprover; // Revert
                alert("Failed to update permissions.");
            }
        }
                
        function enterApp() {
            console.log("ðŸš€ Entering App...");
        
            // Helper to safely hide elements
            const safeHide = (id) => {
                const el = document.getElementById(id);
                if (el) el.classList.add('hidden');
            };
        
            // 1. SAFELY HIDE All Overlays
            safeHide('view-auth');
            safeHide('view-scanner');
            safeHide('view-crop');
            safeHide('add-menu-modal');
            safeHide('invite-modal'); 
        
            // 2. SHOW Main App Components
            const appHeader = document.getElementById('app-header');
            const viewJobs = document.getElementById('view-jobs');
        
            if (appHeader) appHeader.classList.remove('hidden');
            if (viewJobs) viewJobs.classList.remove('hidden');
        
            // 3. ADMIN CHECK: Unlock Management Features
            if (typeof userRole !== 'undefined' && userRole === 'admin') {
                const teamBtn = document.getElementById('btn-team-manager');
                const archiveBtn = document.getElementById('btn-archive');
                const restoreBtn = document.getElementById('btn-manual-restore'); // <--- NEW
                const archiveAlert = document.getElementById('archive-alert');
            
                if (teamBtn) teamBtn.classList.remove('hidden');
                if (archiveBtn) archiveBtn.classList.remove('hidden');
                if (restoreBtn) restoreBtn.classList.remove('hidden'); // <--- NEW
                if (archiveAlert) archiveAlert.classList.remove('hidden');
            } else {
                // Double check they are hidden for non-admins
                safeHide('btn-team-manager');
                safeHide('btn-archive');
                safeHide('btn-manual-restore'); // <--- NEW
                safeHide('archive-alert'); 
            }
                    
            // 4. Load Data
            if (typeof loadJobsFromFirestore === 'function') {
                loadJobsFromFirestore();
            }
        }

        // --- INVITE SYSTEM ---

        function openInviteModal() {
            document.getElementById('invite-modal').classList.remove('hidden');
            loadInvites(); // Fetch list from DB
        }
        
        function closeInviteModal() {
            document.getElementById('invite-modal').classList.add('hidden');
        }
        
        async function loadInvites() {
            const container = document.getElementById('invite-list-container');
            if (!db) return;
        
            try {
                // Get all invites sorted by newest
                const snap = await db.collection('invites').orderBy('createdAt', 'desc').get();
                
                if (snap.empty) {
                    container.innerHTML = `<div class="text-center text-gray-500 py-4 text-xs">No active invites found.</div>`;
                    return;
                }
        
                container.innerHTML = snap.docs.map(doc => {
                    const data = doc.data();
                    const date = new Date(data.createdAt).toLocaleDateString();
                    const isUsed = data.status === 'used';
                    const isRevoked = data.status === 'revoked';
                    
                    // Status Badge Logic
                    let statusHtml = '<span class="text-[10px] text-emerald-400 border border-emerald-500/30 px-1.5 py-0.5 rounded bg-emerald-900/20">Active</span>';
                    if(isUsed) statusHtml = '<span class="text-[10px] text-blue-400 border border-blue-500/30 px-1.5 py-0.5 rounded bg-blue-900/20">Used</span>';
                    if(isRevoked) statusHtml = '<span class="text-[10px] text-red-400 border border-red-500/30 px-1.5 py-0.5 rounded bg-red-900/20">Revoked</span>';
        
                    // Button Logic
                    let actionBtn = '';
                    if (!isUsed && !isRevoked) {
                        actionBtn = `<button onclick="revokeInvite('${doc.id}')" class="p-2 text-red-400 hover:text-white bg-red-900/10 hover:bg-red-900/50 rounded-lg transition-colors" title="Revoke"><i data-lucide="trash-2" class="w-4 h-4"></i></button>`;
                    }
                    
                    // Copy Link Button
                    const linkBtn = `<button onclick="copySpecificLink('${doc.id}')" class="p-2 text-gray-400 hover:text-white bg-gray-700/50 hover:bg-gray-600 rounded-lg transition-colors" title="Copy Link"><i data-lucide="copy" class="w-4 h-4"></i></button>`;
        
                    return `
                        <div class="bg-gray-900/50 p-3 rounded-xl border border-gray-700 flex justify-between items-center">
                            <div>
                                <div class="flex items-center gap-2 mb-1">
                                    <span class="font-mono text-xs text-gray-300">...${doc.id.slice(-6)}</span>
                                    ${statusHtml}
                                </div>
                                <div class="text-[10px] text-gray-500">Created: ${date}</div>
                                ${isUsed ? `<div class="text-[10px] text-blue-400 mt-0.5">Used by: ${data.usedByEmail || 'Unknown'}</div>` : ''}
                            </div>
                            <div class="flex gap-2">
                                ${linkBtn}
                                ${actionBtn}
                            </div>
                        </div>
                    `;
                }).join('');
                
                lucide.createIcons();
            } catch (e) {
                console.error(e);
                container.innerHTML = `<div class="text-center text-red-400 py-4 text-xs">Error loading invites.</div>`;
            }
        }
        
        async function generateNewInvite() {
            if (!db || !currentUser) return;
            
            try {
                const newInviteRef = db.collection('invites').doc(); // Auto-ID
                await newInviteRef.set({
                    createdAt: new Date().toISOString(),
                    createdBy: currentUser.uid,
                    status: 'active', // active, used, revoked
                    usedBy: null
                });
                
                // Auto-copy the link
                copySpecificLink(newInviteRef.id);
                
                // Refresh list
                loadInvites();
                
            } catch (e) {
                alert("Failed to create invite: " + e.message);
            }
        }
        
        async function revokeInvite(inviteId) {
            if(!confirm("Are you sure? This link will stop working immediately.")) return;
            try {
                await db.collection('invites').doc(inviteId).update({ status: 'revoked' });
                loadInvites();
            } catch(e) { alert("Error: " + e.message); }
        }
        
        function copySpecificLink(inviteId) {
            const baseUrl = window.location.href.split('?')[0];
            const inviteUrl = `${baseUrl}?invite=${inviteId}`;
            
            navigator.clipboard.writeText(inviteUrl).then(() => {
                alert("ðŸ”— Link Copied!\n\nSend this to your new team member.");
            });
        }
        
        function logout() {
            firebase.auth().signOut().then(() => {
                window.location.reload(); // Simplest way to reset state
            });
        }
        // --- 2. HELPERS (Must be first) ---
        function parseSizeToBytes(sizeStr) {
            if(!sizeStr) return 0;
            const match = sizeStr.match(/([\d.]+)\s*(kb|mb|gb|b)/i);
            if(!match) return 0;
            const num = parseFloat(match[1]);
            const unit = match[2].toLowerCase();
            if(unit === 'kb') return num * 1024;
            if(unit === 'mb') return num * 1024 * 1024;
            if(unit === 'gb') return num * 1024 * 1024 * 1024;
            return num;
        }

        function getJobStatus(job) {
            if(!job || !job.documents) return 'Open';
            const hasSignedDO = job.documents.some(d => d.docCategory === 'Delivery Order' && d.isSigned === true);
            return hasSignedDO ? 'Completed' : 'Open';
        }

        function getDocBadgesHTML(documents) {
            if(!documents) return '';
            const presentCats = new Set(documents.map(d => d.docCategory));
            
            const badgeOrder = [
                { key: 'Quotation', label: 'QT', color: 'bg-purple-900/40 text-purple-300 border-purple-700/50' },
                { key: 'Purchase Request', label: 'PR', color: 'bg-orange-900/40 text-orange-300 border-orange-700/50' },
                { key: 'Purchase Order', label: 'PO', color: 'bg-emerald-900/40 text-emerald-300 border-emerald-700/50' },
                { key: 'Service Report', label: 'SR', color: 'bg-blue-900/40 text-blue-300 border-blue-700/50' },
                { key: 'Delivery Order', label: 'DO', color: 'bg-cyan-900/40 text-cyan-300 border-cyan-700/50' },
                { key: 'Invoice', label: 'INV', color: 'bg-pink-900/40 text-pink-300 border-pink-700/50' },
                { key: 'Permit to Work', label: 'PTW', color: 'bg-red-900/40 text-red-300 border-red-700/50' },
                { key: 'Other', label: 'OTH', color: 'bg-gray-700/40 text-gray-400 border-gray-600/50' }
            ];

            let html = '';
            badgeOrder.forEach(badge => {
                if (presentCats.has(badge.key)) {
                    html += `<span class="text-[9px] px-1.5 py-0.5 rounded border ${badge.color} uppercase tracking-tight font-bold shadow-sm whitespace-nowrap">
                        <span class="md:hidden">${badge.label}</span>
                        <span class="hidden md:inline">${badge.key}</span>
                    </span>`;
                }
            });
            return html;
        }

        async function processPdfFile(file) {
            const loader = document.createElement('div');
            loader.className = 'fixed inset-0 z-[100] bg-black/80 flex items-center justify-center flex-col text-emerald-400 font-bold';
            loader.innerHTML = '<div class="loader mb-4"></div>Processing PDF Pages...';
            document.body.appendChild(loader);

            try {
                const arrayBuffer = await file.arrayBuffer();
                const pdf = await pdfjsLib.getDocument(arrayBuffer).promise;
                
                batchQueue = [];
                isPdfBatch = true; 

                for (let i = 1; i <= pdf.numPages; i++) {
                    const page = await pdf.getPage(i);
                    const scale = 2.0; 
                    const viewport = page.getViewport({ scale: scale });
                    
                    const canvas = document.createElement('canvas');
                    const context = canvas.getContext('2d');
                    canvas.height = viewport.height;
                    canvas.width = viewport.width;

                    await page.render({ canvasContext: context, viewport: viewport }).promise;
                    
                    const imgData = canvas.toDataURL('image/webp', 0.9);

                    if (i === 1) {
                        closeScanner();
                        openEditor(imgData);
                    } else {
                        batchQueue.push(imgData);
                    }
                }
                
                const title = document.querySelector('#add-menu-modal h3');
                if(title) title.textContent = `PDF: ${pdf.numPages} Pages Loaded`;

            } catch (e) {
                console.error("PDF Error:", e);
                alert("Could not read PDF file.");
            } finally {
                document.body.removeChild(loader);
            }
        }

        function getSafeDocSize(doc) {
            // 1. If it's a string (Base64 - e.g. just scanned), use length 
            // (This works because Base64 is larger than binary, so it's a safe overestimate)
            if (doc.src && typeof doc.src === 'string') {
                return doc.src.length;
            }
        
            // 2. If it's binary (e.g. Restored from Archive), use byte length
            if (doc.src && (doc.src instanceof Uint8Array || doc.src instanceof ArrayBuffer)) {
                return doc.src.byteLength;
            }
        
            // 3. Fallback to stored size property (Standard Database Load)
            if (doc.size) {
                // FIX: Use the helper to convert "500KB" -> 512000 bytes
                return parseSizeToBytes(doc.size); 
            }
        
            return 0;
        }

        function calculateTotalUsage() {
            let totalBytes = 0;
            
            if (jobs) {
                jobs.forEach(job => {
                    // FILTER 1: Exclude entire archived jobs (Ghost jobs)
                    if (job.isArchived) return;
        
                    if (job.documents) {
                        job.documents.forEach(doc => {
                            // FILTER 2: Exclude offline placeholders (Ghost files)
                            if (doc.isOffline) return;
        
                            // Add valid size using the safe helper
                            totalBytes += getSafeDocSize(doc);
                        });
                    }
                });
            }
            
            return totalBytes;
        }
        
        function updateStorageUI() {
            // 1. Get the Safe Total
            const totalBytes = calculateTotalUsage();
            
            // 2. Safety Defaults
            const limitMB = (typeof STORAGE_LIMIT_MB !== 'undefined' && !isNaN(STORAGE_LIMIT_MB)) ? STORAGE_LIMIT_MB : 100;
        
            // 3. Calculate Display Values
            const usedMB = totalBytes / (1024 * 1024);
            let percentage = (limitMB > 0) ? (usedMB / limitMB) * 100 : 0;
            percentage = Math.min(100, Math.max(0, percentage));
        
            // 4. Update DOM
            const textEl = document.getElementById('storage-text');
            if(textEl) textEl.textContent = `${usedMB.toFixed(1)} MB / ${limitMB} MB`;
        
            const bar = document.getElementById('storage-bar');
            if(bar) {
                bar.style.width = `${percentage}%`;
                bar.className = "h-full transition-all duration-500"; // Reset classes
                
                if(percentage > 90) bar.classList.add('bg-red-500');
                else if(percentage > 70) bar.classList.add('bg-yellow-500');
                else bar.classList.add('bg-emerald-500');
            }
        
            // 5. Alert
            const alertBox = document.getElementById('archive-alert');
            if(alertBox) {
                if(percentage >= 80) alertBox.classList.remove('hidden');
                else alertBox.classList.add('hidden');
            }
        }
        
        function renderJobs() {
            const container = document.getElementById('job-container');
            let dataSource = jobs;
            
            if(isViewingArchive) {
                dataSource = archivedJobs;
                if(!document.getElementById('exit-archive-btn')) {
                    const btn = document.createElement('button');
                    btn.id = 'exit-archive-btn';
                    btn.textContent = 'Exit Archive View';
                    btn.className = 'mb-4 w-full py-2 bg-gray-800 border border-gray-600 rounded text-sm text-gray-300';
                    btn.onclick = () => { isViewingArchive = false; archivedJobs = []; renderJobs(); };
                    container.parentNode.insertBefore(btn, container);
                }
            } else {
                const exitBtn = document.getElementById('exit-archive-btn');
                if(exitBtn) exitBtn.remove();
            }

            let filteredJobs = dataSource;
            if (currentSearchTerm) {
                filteredJobs = dataSource.filter(job => {
                    const basicMatch = job.client.toLowerCase().includes(currentSearchTerm) || 
                                     job.id.toLowerCase().includes(currentSearchTerm);
                    if (basicMatch) return true;
                    if(job.documents) {
                        const docMatch = job.documents.some(doc => 
                            doc.ocrText && doc.ocrText.toLowerCase().includes(currentSearchTerm)
                        );
                        return docMatch;
                    }
                    return false;
                });
            }

            if (!filteredJobs || filteredJobs.length === 0) {
                container.innerHTML = `<div class="text-center text-gray-500 py-10">No jobs found. Click + to start.</div>`;
                return;
            }

            const sortedJobs = [...filteredJobs].sort((a, b) => b.id.localeCompare(a.id));

            container.innerHTML = sortedJobs.map(job => {
                const status = getJobStatus(job);
                const statusColor = status === 'Completed' ? 'bg-emerald-900/30 text-emerald-400 border-emerald-900/50' : 'bg-yellow-900/30 text-yellow-400 border-yellow-900/50';
                const borderClass = isViewingArchive ? 'border-purple-500/50' : 'border-gray-700';

                // --- NEW: APPROVAL REQUIRED LOGIC ---
                const pendingCount = job.documents ? job.documents.filter(d => d.requiresSignature && !d.isSigned).length : 0;
                
                let approvalBadge = '';
                if (pendingCount > 0) {
                    approvalBadge = `
                    <div class="flex items-center gap-1 bg-orange-600 text-white px-2 py-1 rounded text-[10px] font-bold uppercase tracking-wider shadow-lg shadow-orange-900/20 animate-pulse ml-2 border border-orange-400">
                        <i data-lucide="alert-triangle" class="w-3 h-3 fill-current"></i>
                        <span>${pendingCount} Approval${pendingCount > 1 ? 's' : ''} Req</span>
                    </div>`;
                }
                // ------------------------------------

                return `
                <div onclick="openJobDetails('${job.id}')" class="bg-gray-800 p-4 rounded-xl border ${borderClass} active:bg-gray-700 transition-colors cursor-pointer flex justify-between items-center group relative overflow-hidden">
                    <div class="absolute left-0 top-0 bottom-0 w-1 ${status === 'Completed' ? 'bg-emerald-500' : 'bg-yellow-500'}"></div>
                    <div class="pl-3 w-full">
                        <div class="flex items-center justify-between mb-2"> <div class="flex items-center flex-wrap gap-y-1">
                                <span class="text-xs font-mono text-gray-500 mr-2">#${job.id}</span>
                                <span class="text-[10px] px-2 py-0.5 rounded border ${statusColor} font-bold tracking-wider uppercase">${status}</span>
                                ${approvalBadge} </div>
                            <span class="text-[10px] text-gray-500 shrink-0 ml-2">${job.date}</span>
                        </div>
                        <h3 class="font-bold text-white text-lg group-hover:text-emerald-400 transition-colors mb-2 leading-tight">${job.client}</h3>
                        <div class="flex flex-wrap gap-1.5 min-h-[1.25rem]">${getDocBadgesHTML(job.documents)}</div>
                    </div>
                    <div class="flex items-center justify-center pl-2 border-l border-gray-700/50"><i data-lucide="chevron-right" class="w-5 h-5 text-gray-500 group-hover:text-white transition-colors"></i></div>
                </div>
            `}).join('');
            
            if(typeof lucide !== 'undefined') lucide.createIcons();
        }
        // --- 4. DATA LOGIC ---
        function loadJobsFromFirestore() {
            if (!db) return;
            db.collection('jobs').onSnapshot((snapshot) => {
                const loadedJobs = [];
                snapshot.forEach((doc) => { loadedJobs.push(doc.data()); });
                jobs = loadedJobs;
                renderJobs();
                updateStorageUI();
            }, (error) => console.error("Error syncing jobs:", error));
        }

        function updateConnectionStatus(isOnline) {
            const statusEl = document.getElementById('connection-status');
            if (isOnline) statusEl.innerHTML = '<div class="w-2 h-2 rounded-full bg-emerald-500 animate-pulse"></div> Online';
            else statusEl.innerHTML = '<div class="w-2 h-2 rounded-full bg-red-500"></div> Offline';
        }

        function initFirebase() {
            if (typeof firebase !== 'undefined') {
                try {
                    // 1. Initialize App
                    if (!firebase.apps.length) {
                        firebase.initializeApp(firebaseConfig);
                    }

                    // 2. ASSIGN GLOBALS IMMEDIATELY
                    // Do not wait for login. We need 'db' ready for the checkSystemStatus() function.
                    db = firebase.firestore();
                    auth = firebase.auth();
                    
                    // Initialize Storage if you use it
                    if (firebase.storage) {
                        storage = firebase.storage();
                    }

                    // 3. Enable Offline Persistence (Optional but recommended)
                    db.enablePersistence().catch(err => {
                        if (err.code == 'failed-precondition') {
                            console.warn('Persistence warning: Multiple tabs open');
                        } else if (err.code == 'unimplemented') {
                            console.warn('Persistence warning: Browser not supported');
                        }
                    });

                    console.log("ðŸ”¥ Firebase Initialized (Waiting for Auth...)");
                    updateConnectionStatus(true);

                    // Note: We REMOVED signInAnonymously() and loadJobsFromFirestore() here.
                    // Your new 'initAuthSystem()' function will handle the login and loading now.

                } catch (e) {
                    console.error("Firebase Init Failed:", e);
                    updateConnectionStatus(false);
                }
            } else { 
                updateConnectionStatus(false); 
            }
        }

        // --- 5. ACTION HANDLERS ---
        function openNewJobModal() {
            if(isViewingArchive) return alert("Please exit archive view.");
            document.getElementById('new-job-modal').classList.remove('hidden');
            document.getElementById('new-job-title').focus();
        }
        function closeNewJobModal() {
            document.getElementById('new-job-modal').classList.add('hidden');
            document.getElementById('new-job-title').value = '';
        }
        function confirmNewJob() {
            const titleInput = document.getElementById('new-job-title');
            const title = titleInput.value.trim();
            if (!title) return alert("Please enter a job title.");
            
            let maxId = 1000; 
            
            const allKnownJobs = [...jobs, ...archivedJobs];
            if (allKnownJobs.length > 0) {
                const ids = allKnownJobs.map(j => {
                    const num = parseInt(j.id.replace(/\D/g, ''), 10); 
                    return isNaN(num) ? 0 : num;
                });
                maxId = Math.max(...ids);
            }
            
            const nextIdNum = maxId + 1;
            const newId = 'J-' + nextIdNum;

            const dateStr = new Date().toLocaleDateString('en-US', { month: 'short', day: 'numeric' });
            
            const newJob = { id: newId, client: title, date: dateStr, documents: [] };
            
            if (db) { 
                db.collection('jobs').doc(newId).set(newJob).catch(e => console.error(e)); 
            }
            
            closeNewJobModal();
        }

        function openRenameJobModal() {
            if (!currentJobId) return;
            const job = jobs.find(j => j.id === currentJobId);
            if (!job) return;

            const modal = document.getElementById('rename-job-modal');
            const input = document.getElementById('rename-job-input');
            input.value = job.client;
            
            modal.classList.remove('hidden');
            setTimeout(() => input.focus(), 100);
        }

        async function confirmJobRename() {
            if (!currentJobId) return;
            
            const input = document.getElementById('rename-job-input');
            const newName = input.value.trim();
            if (!newName) return alert("Please enter a valid name.");

            const modal = document.getElementById('rename-job-modal');
            
            try {
                if (db) {
                    await db.collection('jobs').doc(currentJobId).update({ client: newName });
                }
                const job = jobs.find(j => j.id === currentJobId);
                if (job) job.client = newName;

                document.getElementById('detail-client').textContent = newName;
                renderJobs(); 
                modal.classList.add('hidden');
            } catch (e) {
                console.error("Rename failed", e);
                alert("Failed to rename job.");
            }
        }
        
        function openJobDetails(id) {
            currentJobId = id;
            const sourceList = isViewingArchive ? archivedJobs : jobs;
            const job = sourceList.find(j => j.id === id);
            const status = getJobStatus(job);
            
            document.getElementById('detail-client').textContent = job.client;
            document.getElementById('detail-id').textContent = '#' + job.id;
            const statusEl = document.getElementById('detail-status');
            statusEl.textContent = status;
            statusEl.className = status === 'Completed'
                ? 'text-[10px] px-2 py-1 rounded bg-emerald-900/50 text-emerald-400 font-bold uppercase tracking-wider border border-emerald-800'
                : 'text-[10px] px-2 py-1 rounded bg-yellow-900/50 text-yellow-400 font-bold uppercase tracking-wider border border-yellow-800';
        
            const scanFab = document.getElementById('scan-fab');
            const archiveBadge = document.getElementById('detail-archive-badge');
            if (isViewingArchive) { scanFab.classList.add('hidden'); archiveBadge.classList.remove('hidden'); } 
            else { scanFab.classList.remove('hidden'); archiveBadge.classList.add('hidden'); }
            
            // --- FIX IS HERE ---
            renderDocumentList(job); // Added the function name back
            
            document.getElementById('view-job-details').classList.remove('hidden');
        }
        
        function closeJobDetails() {
            document.getElementById('view-job-details').classList.add('hidden');
            currentJobId = null;
        }

        function renderDocumentList(job) {
            const list = document.getElementById('document-list');
            const emptyState = document.getElementById('empty-docs');
            
            if (!job.documents || job.documents.length === 0) { 
                list.innerHTML = ''; 
                emptyState.classList.remove('hidden'); 
                return; 
            }
            emptyState.classList.add('hidden');
            
            // --- 1. GROUPING ---
            const groups = {};
            const singles = [];

            job.documents.forEach(doc => {
                if (doc.groupId) {
                    if (!groups[doc.groupId]) groups[doc.groupId] = [];
                    groups[doc.groupId].push(doc);
                } else {
                    singles.push(doc);
                }
            });

            // Flatten logic
            let displayItems = [...singles];
            
            Object.values(groups).forEach(groupDocs => {
                groupDocs.sort((a, b) => (a.pageIndex || 0) - (b.pageIndex || 0));
                const mainDoc = groupDocs[0];
                mainDoc._isGroup = true;
                mainDoc._groupDocs = groupDocs; 
                displayItems.push(mainDoc);
            });

            // --- 2. SORTING ---
            const sortWeights = { 'Quotation': 1, 'Purchase Request': 2, 'Purchase Order': 3, 'Service Report': 4, 'Delivery Order': 5, 'Invoice': 6, 'Other': 99 };
            
            displayItems.sort((a, b) => {
                const weightA = sortWeights[a.docCategory] || 99;
                const weightB = sortWeights[b.docCategory] || 99;
                if (weightA !== weightB) return weightA - weightB;
                return b.id.localeCompare(a.id); 
            });
            
            // --- 3. RENDER ---
            list.innerHTML = displayItems.map(item => {
                if (item._isGroup) {
                    // === GROUP ROW (PARENT) ===
                    const groupId = item.groupId;
                    const count = item._groupDocs.length;
                    let groupName = item.name.replace(/\.[^/.]+$/, "").replace(/\s*\(Page\s+\d+\).*/i, '');
                    
                    // --- AGGREGATE STATUS LOGIC (THE FIX) ---
                    // Check if ANY child has a pending requirement
                    const hasPending = item._groupDocs.some(d => d.requiresSignature && !d.isSigned);
                    // Check if ANY child is signed (and no pending issues exist)
                    const hasSigned = !hasPending && item._groupDocs.some(d => d.isSigned);

                    let groupBadge = '';
                    if (hasPending) {
                        // Main Banner Warning
                        groupBadge = `<span class="ml-2 px-2 py-0.5 rounded-full bg-orange-900/40 border border-orange-500 text-[10px] text-orange-400 font-bold uppercase tracking-wider flex items-center gap-1 animate-pulse"><i data-lucide="alert-circle" class="w-3 h-3"></i> Approval Req.</span>`;
                    } else if (hasSigned) {
                        // Main Banner Success
                        groupBadge = `<span class="ml-2 px-2 py-0.5 rounded-full bg-emerald-900/40 border border-emerald-500/50 text-[10px] text-emerald-400 font-bold uppercase tracking-wider flex items-center gap-1"><i data-lucide="check-circle-2" class="w-3 h-3"></i> Signed</span>`;
                    }

                    // Render Children
                    const childrenHtml = item._groupDocs.map(doc => renderSingleRow(job, doc, true)).join('');

                    return `
                    <div class="mb-3 border border-gray-700 rounded-xl overflow-hidden bg-gray-800/50">
                        <div onclick="toggleGroup('${groupId}')" class="p-4 flex justify-between items-center cursor-pointer hover:bg-gray-800 transition-colors">
                            <div class="flex items-center gap-3 overflow-hidden">
                                <div class="w-10 h-10 shrink-0 rounded bg-indigo-900/30 border border-indigo-500/30 flex items-center justify-center text-indigo-400">
                                    <i data-lucide="layers" class="w-5 h-5"></i>
                                </div>
                                <div class="min-w-0">
                                    <div class="flex items-center gap-2">
                                        <h3 class="font-bold text-gray-200 text-sm truncate">${groupName}</h3>
                                        ${groupBadge} </div>
                                    <span class="text-[10px] text-indigo-300 font-mono">${count} Pages</span>
                                </div>
                            </div>
                            
                            <div class="flex gap-2 shrink-0 ml-2">
                                <button onclick="event.stopPropagation(); pendingDownloadDocId='${item.id}'; openDownloadModal('${item.id}', true)" class="p-2 bg-indigo-500/10 text-indigo-400 hover:bg-indigo-500 hover:text-white rounded-lg border border-indigo-500/30 transition-colors" title="Export Combined PDF">
                                    <i data-lucide="file-stack" class="w-4 h-4"></i>
                                </button>
                                <button onclick="event.stopPropagation(); promptDelete('${item.id}', 'group')" class="p-2 bg-red-900/10 text-red-400 hover:bg-red-500 hover:text-white rounded-lg border border-red-900/30 transition-colors" title="Delete Group">
                                    <i data-lucide="trash-2" class="w-4 h-4"></i>
                                </button>
                                <i data-lucide="chevron-down" id="arrow-${groupId}" class="w-4 h-4 text-gray-500 transition-transform duration-300"></i>
                            </div>
                        </div>

                        <div id="group-${groupId}" class="hidden border-t border-gray-700/50 bg-gray-900/30">
                            ${childrenHtml}
                        </div>
                    </div>`;
                } else {
                    // === SINGLE ROW ===
                    return `<div class="mb-3">${renderSingleRow(job, item, false)}</div>`;
                }
            }).join('');
            
            if(typeof lucide !== 'undefined') lucide.createIcons();
        }

        // Helper to render individual rows (Used for Singles AND Children)
        function renderSingleRow(job, doc, isChild) {
            const isOffline = (job.isArchived && doc.isOffline && !doc.src);
            
            // 1. Icon Logic
            let icon = 'file-text';
            if (doc.type === 'img' || doc.type === 'scan') icon = 'image';
            if (doc.type === 'pdf') icon = 'file';
            if (isOffline) icon = 'cloud-off'; 
            
            // 2. Name Logic
            let displayName = doc.name.replace(/\.[^/.]+$/, "");
            if (isChild) {
                // If it's a child, just show "Page 2" instead of "Delivery Order (Page 2)"
                const match = displayName.match(/Page\s+(\d+)/i);
                displayName = match ? `Page ${match[1]}` : displayName;
            }

            // 3. BADGE / BUTTON LOGIC (This puts the buttons on the children)
            let statusBadge = '';
            
            if (isOffline) {
                statusBadge = `<span class="text-[9px] px-1.5 py-0.5 rounded border border-gray-600 text-gray-400 bg-gray-800 uppercase font-bold whitespace-nowrap">OFFLINE</span>`;
            } 
            else if (doc.requiresSignature) {
                // IF PENDING SIGNATURE
                if (doc.isSigned) {
                    const label = doc.approverName ? `by ${doc.approverName}` : 'Signed';
                    // Green "Signed" Button
                    statusBadge = `
                    <button onclick="event.stopPropagation(); toggleDOSigned('${doc.id}')" class="ml-2 px-2 py-0.5 rounded-full bg-emerald-900/40 border border-emerald-500/50 text-[10px] text-emerald-400 font-bold uppercase tracking-wider hover:bg-emerald-900/60 transition-colors flex items-center gap-1 shrink-0">
                        <i data-lucide="check-circle-2" class="w-3 h-3"></i> ${label}
                    </button>`;
                } else {
                    // Orange "Req" Button
                    statusBadge = `
                    <button onclick="event.stopPropagation(); toggleDOSigned('${doc.id}')" class="ml-2 px-2 py-0.5 rounded-full bg-orange-900/40 border border-orange-500 text-[10px] text-orange-400 font-bold uppercase tracking-wider hover:bg-orange-900/60 transition-colors flex items-center gap-1 shrink-0 animate-pulse">
                        <i data-lucide="alert-circle" class="w-3 h-3"></i> Req.
                    </button>`;
                }
            }

            // 4. Action Buttons (Right Side)
            let actionButtons = '';
            if (isViewingArchive || job.isArchived) {
                  actionButtons = `<button class="p-2 text-gray-500 cursor-not-allowed"><i data-lucide="lock" class="w-4 h-4"></i></button>`;
            } else {
                  // Edit Button
                  actionButtons += `<button onclick="event.stopPropagation(); editExistingDoc('${doc.id}')" class="p-2 text-blue-400 hover:text-white bg-blue-900/20 rounded border border-blue-900/50 mr-2" title="Edit Page"><i data-lucide="pen-tool" class="w-4 h-4"></i></button>`;
                  // Delete Button (Pass 'doc' to delete just this page)
                  actionButtons += `<button onclick="event.stopPropagation(); promptDelete('${doc.id}', 'doc')" class="p-2 text-red-400 hover:text-white bg-red-900/20 rounded border border-red-900/50" title="Delete Page"><i data-lucide="trash-2" class="w-4 h-4"></i></button>`;
            }

            // 5. Styling Difference for Child vs Parent
            const paddingClass = isChild ? "pl-12 pr-3 py-3 border-b border-gray-700/50 last:border-0" : "p-3 rounded-lg border border-gray-700 bg-gray-800";
            const bgClass = isChild ? "bg-gray-900/30 hover:bg-gray-900/50" : "hover:bg-gray-700/50";

            return `
            <div onclick="viewDocument('${doc.id}')" class="${paddingClass} ${bgClass} flex justify-between items-center cursor-pointer transition-colors group">
                <div class="flex items-center gap-3 overflow-hidden">
                    <div class="w-8 h-8 shrink-0 rounded bg-gray-900 flex items-center justify-center text-gray-400">
                        <i data-lucide="${icon}" class="w-4 h-4"></i>
                    </div>
                    <div class="min-w-0">
                        <div class="flex items-center gap-2">
                            <p class="text-xs font-medium text-gray-300 group-hover:text-white truncate">${displayName}</p>
                            ${statusBadge} </div>
                        ${!isChild ? `<span class="text-[9px] text-gray-500">${doc.docCategory}</span>` : ''}
                    </div>
                </div>
                <div class="flex gap-2 shrink-0 ml-2">
                    ${!isOffline ? `<button onclick="event.stopPropagation(); openDownloadModal('${doc.id}', false)" class="p-2 text-gray-400 hover:text-white hover:bg-gray-700 rounded"><i data-lucide="download" class="w-4 h-4"></i></button>` : ''}
                    ${actionButtons}
                </div>
            </div>`;
        }
        function toggleGroup(groupId) {
            const container = document.getElementById(`group-${groupId}`);
            const arrow = document.getElementById(`arrow-${groupId}`);
            
            if (container.classList.contains('hidden')) {
                container.classList.remove('hidden');
                arrow.style.transform = "rotate(180deg)";
            } else {
                container.classList.add('hidden');
                arrow.style.transform = "rotate(0deg)";
            }
        }
        // --- LIGHTBOX ZOOM STATE ---
        let lbState = { scale: 1, panning: false, pointX: 0, pointY: 0, startX: 0, startY: 0 };
        
        function initLightboxGestures() {
            const img = document.getElementById('lightbox-img');
            const container = document.getElementById('lightbox-container');
            
            // 1. Mouse Wheel Zoom (PC)
            container.addEventListener('wheel', (e) => {
                e.preventDefault();
                const delta = e.deltaY > 0 ? -0.1 : 0.1;
                updateLightboxZoom(delta);
            });
        
            // 2. Mouse Pan (PC)
            container.addEventListener('mousedown', (e) => {
                e.preventDefault(); // <--- CRITICAL FIX: Stops browser from trying to "drag" the image file
                lbState.panning = true;
                lbState.startX = e.clientX - lbState.pointX;
                lbState.startY = e.clientY - lbState.pointY;
                container.style.cursor = 'grabbing';
            });
        
            window.addEventListener('mousemove', (e) => {
                if (!lbState.panning) return;
                e.preventDefault(); 
                lbState.pointX = e.clientX - lbState.startX;
                lbState.pointY = e.clientY - lbState.startY;
                applyLightboxTransform();
            });
        
            window.addEventListener('mouseup', () => {
                lbState.panning = false;
                container.style.cursor = 'move';
            });
        
            // 3. Touch Gestures (Mobile Pinch & Pan)
            let initialDist = 0;
            let initialScale = 1;
        
            container.addEventListener('touchstart', (e) => {
                if (e.touches.length === 2) {
                    initialDist = Math.hypot(
                        e.touches[0].pageX - e.touches[1].pageX,
                        e.touches[0].pageY - e.touches[1].pageY
                    );
                    initialScale = lbState.scale;
                } else if (e.touches.length === 1) {
                    lbState.panning = true;
                    lbState.startX = e.touches[0].clientX - lbState.pointX;
                    lbState.startY = e.touches[0].clientY - lbState.pointY;
                }
            }, { passive: false });
        
            container.addEventListener('touchmove', (e) => {
                e.preventDefault(); 
                
                if (e.touches.length === 2) {
                    const dist = Math.hypot(
                        e.touches[0].pageX - e.touches[1].pageX,
                        e.touches[0].pageY - e.touches[1].pageY
                    );
                    const delta = dist - initialDist;
                    const newScale = initialScale + (delta * 0.005); 
                    
                    lbState.scale = Math.min(Math.max(0.5, newScale), 20);
                    updateZoomDisplay();
                    applyLightboxTransform();
                } 
                else if (e.touches.length === 1 && lbState.panning) {
                    lbState.pointX = e.touches[0].clientX - lbState.startX;
                    lbState.pointY = e.touches[0].clientY - lbState.startY;
                    applyLightboxTransform();
                }
            }, { passive: false });
        
            container.addEventListener('touchend', () => {
                lbState.panning = false;
            });
        }

        function updateLightboxZoom(delta) {
            lbState.scale += delta;
            lbState.scale = Math.min(Math.max(0.5, lbState.scale), 20); // Min 0.5x, Max 5x
            updateZoomDisplay();
            applyLightboxTransform();
        }
        
        function resetLightboxZoom() {
            lbState = { scale: 1, panning: false, pointX: 0, pointY: 0, startX: 0, startY: 0 };
            updateZoomDisplay();
            applyLightboxTransform();
        }
        
        function applyLightboxTransform() {
            const img = document.getElementById('lightbox-img');
            if(img) {
                img.style.transform = `translate(${lbState.pointX}px, ${lbState.pointY}px) scale(${lbState.scale})`;
            }
        }
        
        function updateZoomDisplay() {
            const display = document.getElementById('lightbox-zoom-display');
            if(display) display.innerText = Math.round(lbState.scale * 100) + '%';
        }

        // --- EDITOR ZOOM LOGIC ---

        function initFabricZoom() {
            if (!fabricCanvas) return;
        
            // 1. Mouse Wheel Zoom
            fabricCanvas.on('mouse:wheel', function(opt) {
                var delta = opt.e.deltaY;
                var zoom = fabricCanvas.getZoom();
                zoom *= 0.999 ** delta;
                if (zoom > 5) zoom = 5;
                if (zoom < 0.5) zoom = 0.5;
                
                // Zoom to point of mouse
                fabricCanvas.zoomToPoint({ x: opt.e.offsetX, y: opt.e.offsetY }, zoom);
                opt.e.preventDefault();
                opt.e.stopPropagation();
                updateEditorZoomDisplay();
            });
        
            // 2. Touch Pinch Zoom
            // Fabric doesn't support pinch natively on all versions, so we use the canvas wrapper events
            let initialPinchDist = 0;
            let initialZoom = 1;
            const canvasWrapper = document.querySelector('.canvas-container'); // Fabric wrapper
        
            if(canvasWrapper) {
                canvasWrapper.addEventListener('touchstart', (e) => {
                    if (e.touches.length === 2) {
                        e.preventDefault();
                        initialPinchDist = Math.hypot(
                            e.touches[0].pageX - e.touches[1].pageX,
                            e.touches[0].pageY - e.touches[1].pageY
                        );
                        initialZoom = fabricCanvas.getZoom();
                    }
                }, { passive: false });
        
                canvasWrapper.addEventListener('touchmove', (e) => {
                    if (e.touches.length === 2) {
                        e.preventDefault();
                        const dist = Math.hypot(
                            e.touches[0].pageX - e.touches[1].pageX,
                            e.touches[0].pageY - e.touches[1].pageY
                        );
                        const scaleFactor = dist / initialPinchDist;
                        let newZoom = initialZoom * scaleFactor;
                        
                        // Clamp
                        if (newZoom > 5) newZoom = 5;
                        if (newZoom < 0.5) newZoom = 0.5;
        
                        // Zoom to center of the two fingers
                        const center = {
                            x: (e.touches[0].pageX + e.touches[1].pageX) / 2,
                            y: (e.touches[0].pageY + e.touches[1].pageY) / 2
                        };
                        
                        // Need to account for canvas offset on screen
                        const rect = canvasWrapper.getBoundingClientRect();
                        const localCenter = {
                            x: center.x - rect.left,
                            y: center.y - rect.top
                        };
        
                        fabricCanvas.zoomToPoint(localCenter, newZoom);
                        updateEditorZoomDisplay();
                    }
                }, { passive: false });
            }
        
            // 3. Panning Logic (Hold Shift + Drag OR Two fingers drag)
            let isDragging = false;
            let lastPosX, lastPosY;
        
            fabricCanvas.on('mouse:down', function(opt) {
                var evt = opt.e;
                // Allow pan if holding Shift Key (PC) or Alt Key
                if (evt.shiftKey === true || evt.altKey === true) {
                    this.isDragging = true;
                    this.selection = false; // Disable selection while panning
                    this.lastPosX = evt.clientX;
                    this.lastPosY = evt.clientY;
                }
            });
        
            fabricCanvas.on('mouse:move', function(opt) {
                if (this.isDragging) {
                    var e = opt.e;
                    var vpt = this.viewportTransform;
                    vpt[4] += e.clientX - this.lastPosX;
                    vpt[5] += e.clientY - this.lastPosY;
                    this.requestRenderAll();
                    this.lastPosX = e.clientX;
                    this.lastPosY = e.clientY;
                }
            });
        
            fabricCanvas.on('mouse:up', function(opt) {
                // on mouse up we want to recalculate new interaction
                // for all objects, so we call setViewportTransform
                if(this.isDragging) {
                    this.setViewportTransform(this.viewportTransform);
                    this.isDragging = false;
                    this.selection = true;
                }
            });
        }
        
        function adjustEditorZoom(delta) {
            if (!fabricCanvas) return;
            let zoom = fabricCanvas.getZoom();
            zoom += delta;
            if (zoom > 5) zoom = 5;
            if (zoom < 0.5) zoom = 0.5;
            
            // Zoom to center of canvas
            fabricCanvas.zoomToPoint({ x: fabricCanvas.width / 2, y: fabricCanvas.height / 2 }, zoom);
            updateEditorZoomDisplay();
        }
        
        function resetEditorZoom() {
            if (!fabricCanvas || !fabricCanvas.backgroundImage) return;
            // Fit to screen logic
            // We can just call our existing openEditor logic which calculates "scale"
            // Or simpler: reset viewport
            fabricCanvas.setViewportTransform([1, 0, 0, 1, 0, 0]);
            
            // Re-center the background image if needed
            const img = fabricCanvas.backgroundImage;
            if(img) {
                // Recalculate the original fit scale
                const container = document.getElementById('view-editor').querySelector('.flex-1');
                const maxWidth = container.clientWidth - 40; 
                const maxHeight = container.clientHeight - 80;
                // ... (This mimics the logic in openEditor)
                // For simplicity, we just reset zoom level to 1, user can adjust.
                fabricCanvas.setZoom(1);
                fabricCanvas.requestRenderAll();
            }
            updateEditorZoomDisplay();
        }
        
        function updateEditorZoomDisplay() {
            const el = document.getElementById('editor-zoom-display');
            if (fabricCanvas && el) {
                el.innerText = Math.round(fabricCanvas.getZoom() * 100) + '%';
            }
        }
        
        async function toggleDOSigned(docId) {
            if (!currentJobId) return;
            const job = jobs.find(j => j.id === currentJobId);
            const doc = job.documents.find(d => d.id === docId);
            if (!doc) return;
        
            // --- STRICT PERMISSION CHECK ---
            if (doc.requiresSignature) {
                // If the document is marked "Require Manager Approval":
                // We ONLY allow users who have the 'isApprover' flag.
                // Even Admins get blocked here if they don't have the checkbox ticked.
                if (!userIsApprover) {
                    alert("â›” Authorization Required\n\nYou can edit/upload the document, but only a designated Approver can mark it as Final/Signed.");
                    return;
                }
            } 
            // Note: If requiresSignature is FALSE, we allow anyone to toggle it (standard workflow),
            // or you can restrict that too if you prefer.
        
            // 2. PREPARE DATA
            const newStatus = !doc.isSigned;
            
            // Capture the name of the actual person clicking the button
            const approverName = newStatus ? (currentUser.email.split('@')[0]) : null;
            const approverUid = newStatus ? currentUser.uid : null;
        
            // 3. OPTIMISTIC UPDATE
            doc.isSigned = newStatus;
            doc.approverName = approverName;
            doc.approverUid = approverUid;
            
            renderDocumentList(job); 
            
            // 4. DATABASE SYNC
            if (db) {
                try {
                    const jobRef = db.collection('jobs').doc(currentJobId);
                    const jobSnap = await jobRef.get();
                    if (jobSnap.exists) {
                        let currentDocs = jobSnap.data().documents;
                        const idx = currentDocs.findIndex(d => d.id === docId);
                        if (idx !== -1) {
                            currentDocs[idx].isSigned = newStatus;
                            currentDocs[idx].approverName = approverName;
                            currentDocs[idx].approverUid = approverUid;
                            await jobRef.update({ documents: currentDocs });
                        }
                    }
                } catch (e) {
                    console.error("Sync Error:", e);
                    alert("Sync failed. Check connection.");
                    doc.isSigned = !newStatus; // Revert
                    renderDocumentList(job);
                }
            }
        }
        
        function editExistingDoc(docId) {
            if(isViewingArchive) return;
            editingDocId = docId;
            const job = jobs.find(j => j.id === currentJobId);
            const doc = job.documents.find(d => d.id === docId);
            if(!doc) return;
            const btn = event.currentTarget; 
            const originalIcon = btn.innerHTML;
            btn.innerHTML = '<div class="loader w-4 h-4 border-t-blue-500"></div>';
            ensureDocImageLoaded(job, doc).then(imgSrc => {
                btn.innerHTML = originalIcon;
                if (imgSrc) {
                    document.getElementById('view-job-details').classList.add('hidden');
                    openEditor(imgSrc);
                } else { alert("Could not load image. It might be missing from cloud or offline."); }
            });
        }

        let lightboxGesturesInit = false; // Flag to ensure listeners are added only once

        function viewDocument(docId) {
            const sourceList = isViewingArchive ? archivedJobs : jobs;
            const job = sourceList.find(j => j.id === currentJobId);
            const doc = job.documents.find(d => d.id === docId);
            if(!doc) return;
        
            // --- COLD STORAGE CHECK ---
            if (job.isArchived && doc.isOffline && !doc.src) {
                const requiredFile = job.archiveFilename || "the archive file";
                const confirmLoad = confirm(
                    `ðŸ”’ Content Offline\n\nTo view this image, you need to load the backup file:\n\nðŸ“‚ ${requiredFile}\n\nWould you like to load it now?`
                );
                
                if (confirmLoad) {
                    viewingDocId = docId; 
                    document.getElementById('archive-upload').click();
                }
                return;
            }
            // ---------------------------
        
            viewingDocId = docId; 
            document.body.style.cursor = 'wait';
        
            // 1. RESET ZOOM STATE BEFORE OPENING
            resetLightboxZoom();
        
            ensureDocImageLoaded(job, doc).then(imgSrc => {
                document.body.style.cursor = 'default';
                if (imgSrc) {
                    const lightbox = document.getElementById('view-lightbox');
                    const img = document.getElementById('lightbox-img');
                    const editBtn = document.getElementById('lightbox-edit-btn');
                    const nameInput = document.getElementById('lightbox-filename');
                    
                    img.src = imgSrc;
                    nameInput.value = doc.name.replace(/\.[^/.]+$/, "");
                    
                    // --- FIX: BUTTON LOGIC ---
                    if (job.isArchived) {
                        editBtn.classList.add('hidden');
                        nameInput.disabled = true;
                    } else {
                        editBtn.classList.remove('hidden');
                        nameInput.disabled = false;
                        
                        // ATTACH CLICK LISTENER HERE
                        editBtn.onclick = function() {
                            closeLightbox(); // Close preview first
                            editExistingDoc(docId); // Open editor
                        };
                    }
                    
                    lightbox.classList.remove('hidden');
        
                    // 2. INITIALIZE GESTURES (ONCE)
                    if (!lightboxGesturesInit) {
                        initLightboxGestures();
                        lightboxGesturesInit = true;
                    }
        
                } else {
                    alert("Error: Image data not found.");
                }
            });
        }

        // --- DELETE LOGIC ---
        let pendingDeleteId = null;

        function promptDelete(id, type = 'doc') {
            pendingDeleteId = id;
            pendingDeleteType = type; // 'job', 'group', or 'doc'
            
            const modal = document.getElementById('delete-modal');
            const title = document.getElementById('delete-modal-title');
            const input = document.getElementById('delete-confirmation-input');
            const btn = document.getElementById('btn-confirm-delete');
            
            // Reset state
            input.value = '';
            btn.innerHTML = '<span>Delete</span>';
            btn.disabled = true;
            btn.className = "flex-1 py-3 bg-gray-700 text-gray-500 font-bold rounded-xl transition-all cursor-not-allowed flex justify-center items-center gap-2";
        
            // Text Logic
            if (type === 'job') {
                title.textContent = "Delete Entire Job?";
                title.classList.add('text-red-400');
            } 
            else if (type === 'group') {
                // Find how many pages are in this group for the title
                const job = jobs.find(j => j.id === currentJobId);
                const doc = job ? job.documents.find(d => d.id === id) : null;
                const count = (doc && doc.groupId) ? job.documents.filter(d => d.groupId === doc.groupId).length : 'Group';
                
                title.textContent = `Delete Stack (${count})?`;
                title.classList.remove('text-red-400');
            } 
            else {
                title.textContent = "Delete Document?";
                title.classList.remove('text-red-400');
            }
            
            modal.classList.remove('hidden');
            setTimeout(() => modal.classList.remove('opacity-0'), 10);
            setTimeout(() => input.focus(), 100);
        }

        function closeDeleteModal() {
            const modal = document.getElementById('delete-modal');
            modal.classList.add('opacity-0');
            setTimeout(() => {
                modal.classList.add('hidden');
                pendingDeleteId = null;
            }, 200);
        }

        function validateDeleteInput(input) {
            const btn = document.getElementById('btn-confirm-delete');
            const val = input.value.trim().toLowerCase();
            
            if (val === 'delete') {
                btn.disabled = false;
                btn.className = "flex-1 py-3 bg-red-600 text-white hover:bg-red-500 font-bold rounded-xl shadow-lg shadow-red-900/40 active:scale-95 transition-all flex justify-center items-center gap-2";
            } else {
                btn.disabled = true;
                btn.className = "flex-1 py-3 bg-gray-700 text-gray-500 font-bold rounded-xl transition-all cursor-not-allowed flex justify-center items-center gap-2";
            }
        }

        async function executeDelete() {
            if (!pendingDeleteId) return;
            
            const btn = document.getElementById('btn-confirm-delete');
            const originalText = btn.innerHTML;
            btn.innerHTML = '<div class="loader w-4 h-4 border-t-white"></div>';
            
            try {
                // 1. DELETE JOB (Entire Folder)
                if (pendingDeleteType === 'job') {
                    if (db) {
                        const jobRef = db.collection('jobs').doc(pendingDeleteId);
                        const snapshot = await jobRef.collection('scans').get();
                        const batch = db.batch();
                        snapshot.docs.forEach(doc => batch.delete(doc.ref));
                        batch.delete(jobRef);
                        await batch.commit();
                    }
                    // UI Update
                    jobs = jobs.filter(j => j.id !== pendingDeleteId);
                    if(currentJobId === pendingDeleteId) closeJobDetails();
                    renderJobs();
                    alert("Job deleted successfully.");
                } 
                
                // 2. DELETE DOCUMENTS (Group or Single)
                else {
                    const jobRef = db ? db.collection('jobs').doc(currentJobId) : null;
                    let idsToDelete = [];
        
                    // A. Determine which IDs to delete based on Type
                    const job = jobs.find(j => j.id === currentJobId);
                    if (!job) throw new Error("Job not found locally");
        
                    const targetDoc = job.documents.find(d => d.id === pendingDeleteId);
                    
                    if (pendingDeleteType === 'group' && targetDoc && targetDoc.groupId) {
                        // DELETE ALL SIBLINGS IN THE GROUP
                        const siblings = job.documents.filter(d => d.groupId === targetDoc.groupId);
                        idsToDelete = siblings.map(s => s.id);
                    } else {
                        // DELETE ONLY THIS SPECIFIC FILE
                        idsToDelete = [pendingDeleteId];
                    }
        
                    // B. Database Update
                    if (db && jobRef) {
                        // 1. Update the array in the main job document
                        const jobSnap = await jobRef.get();
                        if (jobSnap.exists) {
                            const currentDocs = jobSnap.data().documents || [];
                            const updatedDocs = currentDocs.filter(d => !idsToDelete.includes(d.id));
                            await jobRef.update({ documents: updatedDocs });
                        }
        
                        // 2. Delete the actual sub-collection documents
                        const batch = db.batch();
                        idsToDelete.forEach(id => {
                            const ref = jobRef.collection('scans').doc(id);
                            batch.delete(ref);
                        });
                        await batch.commit();
                    }
        
                    // C. Local UI Update
                    job.documents = job.documents.filter(d => !idsToDelete.includes(d.id));
                    renderDocumentList(job);
                }
        
                closeDeleteModal();
        
            } catch (err) {
                console.error("Delete failed:", err);
                alert("Failed to delete. Please check connection.");
                btn.innerHTML = originalText;
                closeDeleteModal();
            }
        }
                
        async function saveDocumentRename() {
            if (!viewingDocId || !currentJobId) return;

            const nameInput = document.getElementById('lightbox-filename');
            const feedback = document.getElementById('rename-feedback');
            const cleanName = nameInput.value.trim();
            
            if (!cleanName) return; 

            const finalName = cleanName + '.webp';
            const job = jobs.find(j => j.id === currentJobId);
            const doc = job.documents.find(d => d.id === viewingDocId);
            if (doc) {
                doc.name = finalName;
                renderDocumentList(job); 
            }

            feedback.classList.remove('opacity-0');
            setTimeout(() => feedback.classList.add('opacity-0'), 2000);

            if (db) {
                try {
                    const jobRef = db.collection('jobs').doc(currentJobId);
                    const jobSnap = await jobRef.get();
                    if (jobSnap.exists) {
                        let currentDocs = jobSnap.data().documents;
                        const idx = currentDocs.findIndex(d => d.id === viewingDocId);
                        if (idx !== -1) {
                            currentDocs[idx].name = finalName;
                            await jobRef.update({ documents: currentDocs });
                            await db.collection('jobs').doc(currentJobId).collection('scans').doc(viewingDocId).update({ name: finalName });
                        }
                    }
                } catch (e) {
                    console.error("Rename failed:", e);
                    feedback.textContent = "Error saving";
                    feedback.classList.add('text-red-500');
                }
            }
        }

        function closeLightbox() {
            document.getElementById('view-lightbox').classList.add('hidden');
            viewingDocId = null;
            setTimeout(() => { document.getElementById('lightbox-img').src = ''; }, 200);
        }

       async function ensureDocImageLoaded(job, doc) {
            // 1. Check for Offline/Restored Data (Uint8Array or ArrayBuffer)
            if (doc.src) {
                // If it's ALREADY a String (Base64 or Blob URL), return it
                if (typeof doc.src === 'string' && doc.src.length > 0) return doc.src;
        
                // If it's BINARY (from CBOR load), convert to Blob URL for display
                if (doc.src instanceof Uint8Array || doc.src instanceof ArrayBuffer) {
                    const blob = new Blob([doc.src], { type: 'image/webp' }); // Assume WebP
                    const url = URL.createObjectURL(blob);
                    
                    // OPTIONAL: Cache it as a string so we don't recreate the blob every click
                    // doc.src = url; 
                    
                    return url;
                }
            }
        
            // 2. If viewing archive and no data, stop.
            if (isViewingArchive) return null;
            
            // 3. Try Firestore (Standard Cloud Load)
            if (db && doc.id) {
                try {
                    const docRef = db.collection('jobs').doc(job.id).collection('scans').doc(doc.id);
                    const snapshot = await docRef.get();
                    if (snapshot.exists) {
                        const data = snapshot.data();
                        if (data.image_blob) {
                            // Firestore stores binary as a special object, convert to standard Blob
                            const uint8Array = data.image_blob.toUint8Array();
                            const blob = new Blob([uint8Array], { type: 'image/webp' });
                            const url = URL.createObjectURL(blob);
                            doc.src = url; 
                            return url;
                        } else if (data.src) {
                            return data.src;
                        }
                    }
                } catch (e) { console.error("Error fetching image:", e); }
            }
            return null;
        }

        function handleAddPage() {
            if (!fabricCanvas) return;
            const multiplier = 2; 
            const dataURL = fabricCanvas.toDataURL({ format: 'webp', quality: 0.9, multiplier: multiplier });
            batchQueue.push(dataURL);

            const btn = event.currentTarget;
            const originalText = btn.innerHTML;
            btn.innerHTML = `<span class='text-green-400'>Added!</span>`;
            
            setTimeout(() => {
                btn.innerHTML = originalText;
                document.getElementById('view-editor').classList.add('hidden');
                openAddMenu();
                const title = document.querySelector('#add-menu-modal h3');
                if(title) title.textContent = `Add Page ${batchQueue.length + 1}`;
            }, 400);
        }

        // --- SIMPLE SCANNER ENGINE ---
        let video = null;
        // isScanning is declared globally at the top
        // cvReady is declared globally at the top

        // Wait for OpenCV (Only needed for the CROP/ENHANCE stage later)
        if(typeof cv !== 'undefined') {
             cv['onRuntimeInitialized'] = () => { cvReady = true; console.log("OpenCV Loaded"); };
        }

        function openScanner() {
            document.getElementById('view-scanner').classList.remove('hidden');
            video = document.getElementById('video');
            
            // Robust Camera Constraints
            const constraints = {
                audio: false,
                video: {
                    facingMode: 'environment', // Rear camera
                    width: { ideal: 1920 },    // Try for HD
                    height: { ideal: 1080 }
                }
            };

            navigator.mediaDevices.getUserMedia(constraints)
                .then(s => {
                    stream = s;
                    video.srcObject = stream;
                    video.onloadedmetadata = () => {
                        video.play().catch(e => console.error("Play error:", e));
                    };
                })
                .catch(err => {
                    console.error("Camera Error:", err);
                    alert("Could not access camera. Please check permissions or use 'Upload Image'.");
                    closeScanner();
                });
        }

        function closeScanner() {
            if (stream) {
                stream.getTracks().forEach(t => t.stop());
                stream = null;
            }
            document.getElementById('view-scanner').classList.add('hidden');
            
            // Safety: If we were in Stamp Mode and cancelled camera, go back to Editor
            if (isStampMode) {
                isStampMode = false;
                document.getElementById('view-editor').classList.remove('hidden');
            }
        }

        function captureDoc() {
            if (!video || !video.videoWidth) return;

            // 1. Prepare the Canvas
            const fullCanvas = document.createElement('canvas');
            fullCanvas.width = video.videoWidth;
            fullCanvas.height = video.videoHeight;
            const fullCtx = fullCanvas.getContext('2d');
            
            // Flip horizontal if using front camera (optional, usually for selfies)
            // fullCtx.translate(fullCanvas.width, 0);
            // fullCtx.scale(-1, 1);
            
            fullCtx.drawImage(video, 0, 0, fullCanvas.width, fullCanvas.height);
            
            // 2. Get the Image Data
            const fullImageSrc = fullCanvas.toDataURL('image/jpeg', 0.95);
            
            // 3. Traffic Control: Where does this image go?
            if (isStampMode) {
                // --- A. STAMP MODE ---
                // We are capturing a stamp (signature/chop)
                captureSource = 'camera'; 
                
                // Close the scanner view immediately
                document.getElementById('view-scanner').classList.add('hidden');
                
                // Stop camera stream to save battery
                if (stream) {
                    stream.getTracks().forEach(track => track.stop());
                    stream = null;
                }

                // Open Crop View specifically for stamps
                openCropView(fullImageSrc, null); // Pass null for corners since we don't auto-detect stamps usually

            } else {
                // --- B. DOCUMENT MODE ---
                // We are capturing a regular document page
                captureSource = 'camera'; 
                
                // If we are in "Batch Mode", just add to queue
                // (Assuming you might add batch mode logic here later)
                
                // For now, standard single capture flow:
                document.getElementById('view-scanner').classList.add('hidden');
                
                if (stream) {
                    stream.getTracks().forEach(track => track.stop());
                    stream = null;
                }
                
                // Detect corners (optional) or just open crop
                // For speed, we just open crop view
                openCropView(fullImageSrc, null); 
            }
        }
        // --- CROPPER STATE ---
        let cropPoints = []; 
        let activePointIndex = -1; 
        let cropImgElement = null;
        let cropCanvas = null;
        let originalCaptureSrc = null; 

        function openCropView(imageSrc, detectedCorners) {
            document.getElementById('view-scanner').classList.add('hidden'); 
            const view = document.getElementById('view-crop');
            view.classList.remove('hidden');
            
            cropImgElement = document.getElementById('crop-img');
            cropCanvas = document.getElementById('crop-overlay');
            originalCaptureSrc = imageSrc;

            cropImgElement.src = imageSrc;
            
            // --- NEW: Add Padding for Stamps ---
            // This physically expands the element so the canvas sitting on top
            // is larger than the visible image.
            if (isStampMode) {
                cropImgElement.style.padding = '40px'; 
                cropImgElement.style.backgroundColor = '#1f2937'; // Dark gray background for the padding area
            } else {
                cropImgElement.style.padding = '0px';
                cropImgElement.style.backgroundColor = 'transparent';
            }

            // Wait for layout
            cropImgElement.onload = () => {
                requestAnimationFrame(() => {
                    requestAnimationFrame(() => {
                        const rect = cropImgElement.getBoundingClientRect();
                        const dpr = window.devicePixelRatio || 1;
                        
                        // Canvas matches the padded size
                        cropCanvas.width = rect.width * dpr;
                        cropCanvas.height = rect.height * dpr;
                        cropCanvas.style.width = rect.width + 'px';
                        cropCanvas.style.height = rect.height + 'px';
                        cropCanvas.style.left = rect.left + 'px';
                        cropCanvas.style.top = rect.top + 'px';
                        
                        initCropPoints(detectedCorners);
                        renderCropUI();
                        initCropListeners();
                    });
                });
            };
        }

        function closeCropView() {
            document.getElementById('view-crop').classList.add('hidden');
            
            // --- SMART RETAKE LOGIC ---
            if (isStampMode) {
                // We are cancelling a stamp crop. Where should we go?
                
                if (captureSource === 'camera') {
                    openScanner(); // Re-open camera immediately
                } else if (captureSource === 'upload') {
                    // Re-open file picker, but first show editor so we don't stare at a blank screen
                    document.getElementById('view-editor').classList.remove('hidden');
                    setTimeout(() => triggerStampInput(), 100);
                } else {
                    // For 'paste', just go back to editor and open the menu
                    document.getElementById('view-editor').classList.remove('hidden');
                    setTimeout(() => {
                        const menu = document.getElementById('stamp-options-menu');
                        menu.classList.remove('hidden'); // Re-show the menu
                    }, 100);
                }
            } else {
                // Document Mode Logic
                if (captureSource === 'upload') {
                    document.getElementById('doc-upload-input').click();
                } else if (captureSource === 'paste') {
                    openAddMenu(); 
                } else {
                    openScanner(); 
                }
            }
            
            // Important: Don't reset isStampMode yet if we are looping back to camera!
            // But if we are going back to the menu/editor (cancel), we should reset it.
            if (captureSource === 'paste' || captureSource === 'upload') {
                isStampMode = false; 
            }
        }

        function initCropPoints(autoCorners) {
            const w = cropCanvas.width;
            const h = cropCanvas.height;
            
            if (isStampMode) {
                // --- STAMP MODE: SMALL CENTERED BOX ---
                // Create a smaller box in the absolute center
                // This is much better for small signatures
                const boxSize = Math.min(w, h) * 0.4; // 40% of screen width
                const centerX = w / 2;
                const centerY = h / 2;
                
                cropPoints = [
                    { x: centerX - boxSize/2, y: centerY - boxSize/2 }, // TL
                    { x: centerX + boxSize/2, y: centerY - boxSize/2 }, // TR
                    { x: centerX + boxSize/2, y: centerY + boxSize/2 }, // BR
                    { x: centerX - boxSize/2, y: centerY + boxSize/2 }  // BL
                ];
            } else {
                // --- DOCUMENT MODE: FULL PAGE BOX ---
                // Use 15% padding from edges
                const padX = w * 0.15;
                const padY = h * 0.15;
                
                cropPoints = [
                    { x: padX, y: padY },             // TL
                    { x: w - padX, y: padY },         // TR
                    { x: w - padX, y: h - padY },     // BR
                    { x: padX, y: h - padY }          // BL
                ];
            }
        }

        function renderCropUI() {
            const ctx = cropCanvas.getContext('2d');
            
            // Clear & Draw Mask
            ctx.clearRect(0, 0, cropCanvas.width, cropCanvas.height);
            ctx.fillStyle = 'rgba(0, 0, 0, 0.6)'; 
            ctx.fillRect(0, 0, cropCanvas.width, cropCanvas.height);
            
            ctx.save();
            ctx.globalCompositeOperation = 'destination-out';
            ctx.beginPath();
            ctx.moveTo(cropPoints[0].x, cropPoints[0].y);
            ctx.lineTo(cropPoints[1].x, cropPoints[1].y);
            ctx.lineTo(cropPoints[2].x, cropPoints[2].y);
            ctx.lineTo(cropPoints[3].x, cropPoints[3].y);
            ctx.closePath();
            ctx.fill();
            ctx.restore();

            // Draw Lines
            ctx.beginPath();
            ctx.strokeStyle = '#10b981'; 
            ctx.lineWidth = 3;
            ctx.moveTo(cropPoints[0].x, cropPoints[0].y);
            ctx.lineTo(cropPoints[1].x, cropPoints[1].y);
            ctx.lineTo(cropPoints[2].x, cropPoints[2].y);
            ctx.lineTo(cropPoints[3].x, cropPoints[3].y);
            ctx.closePath();
            ctx.stroke();

            // Draw Handles
            cropPoints.forEach((p, i) => {
                const isActive = (i === activePointIndex);
                
                // Outer Glow
                ctx.beginPath();
                ctx.arc(p.x, p.y, 30, 0, Math.PI * 2); 
                ctx.fillStyle = 'rgba(16, 185, 129, 0.2)'; 
                ctx.fill();

                // Inner Handle
                ctx.beginPath();
                ctx.arc(p.x, p.y, 10, 0, Math.PI * 2); 
                ctx.fillStyle = isActive ? '#34d399' : '#10b981'; 
                ctx.fill();
                ctx.strokeStyle = 'white';
                ctx.lineWidth = 2;
                ctx.stroke();
            });
            
            // --- 5. FIXED CORNER MAGNIFIER (The New Feature) ---
            if(activePointIndex !== -1 && cropImgElement) {
                const p = cropPoints[activePointIndex]; // The point we are dragging
                
                // Config
                const size = 120;     // Size of the square preview box
                const margin = 20;    // Margin from the screen edge
                const zoom = 2.5;     // Zoom level
                
                // 1. Determine Position (Corner Swap Logic)
                // Default: Top-Left
                let previewX = margin;
                let previewY = margin;

                // Check if finger is in the Top-Left quadrant
                // If we are dragging near the Top-Left, move preview to Top-Right
                // so the box doesn't cover the point we are trying to see.
                if (p.x < (cropCanvas.width / 2) && p.y < (cropCanvas.height / 2)) {
                    previewX = cropCanvas.width - size - margin;
                }

                // 2. Draw Preview Container (Square Box)
                ctx.save();
                ctx.beginPath();
                // Draw a rounded rectangle for style
                ctx.roundRect(previewX, previewY, size, size, 12);
                ctx.fillStyle = '#1f2937'; // Dark Gray bg
                ctx.fill();
                ctx.strokeStyle = 'white';
                ctx.lineWidth = 3;
                ctx.stroke();
                
                // Add Shadow
                ctx.shadowColor = 'rgba(0,0,0,0.5)';
                ctx.shadowBlur = 15;
                ctx.stroke();
                ctx.shadowBlur = 0;

                // Clip area for image
                ctx.clip();

                // 3. Draw Zoomed Image
                const imgRatioX = cropImgElement.naturalWidth / cropCanvas.width;
                const imgRatioY = cropImgElement.naturalHeight / cropCanvas.height;

                const sW = size / zoom * imgRatioX;
                const sH = size / zoom * imgRatioY;
                const sX = (p.x * imgRatioX) - (sW / 2);
                const sY = (p.y * imgRatioY) - (sH / 2);

                if (cropImgElement.complete && cropImgElement.naturalWidth > 0) {
                     ctx.drawImage(
                        cropImgElement, 
                        sX, sY, sW, sH, 
                        previewX, previewY, size, size
                    );
                }

                // 4. Draw Crosshair (Fixed in Center of Preview Box)
                const cx = previewX + size/2;
                const cy = previewY + size/2;

                ctx.strokeStyle = '#10b981'; // Emerald Green Crosshair
                ctx.lineWidth = 2;
                ctx.beginPath();
                
                // Full crosshair
                ctx.moveTo(cx, previewY); ctx.lineTo(cx, previewY + size);
                ctx.moveTo(previewX, cy); ctx.lineTo(previewX + size, cy);
                ctx.stroke();
                
                // Add a small red dot in the exact center for precision
                ctx.beginPath();
                ctx.arc(cx, cy, 2, 0, Math.PI*2);
                ctx.fillStyle = 'red';
                ctx.fill();

                ctx.restore();
            }
        }

        function initCropListeners() {
            const canvas = cropCanvas;
            
            const getPos = (e) => {
                // 1. Get the visual size and position of the canvas on screen
                const rect = canvas.getBoundingClientRect();
                
                // 2. Handle Touch vs Mouse
                // Note: e.touches is for 'start/move', e.changedTouches is for 'end'
                const clientX = e.touches ? (e.touches[0] ? e.touches[0].clientX : e.changedTouches[0].clientX) : e.clientX;
                const clientY = e.touches ? (e.touches[0] ? e.touches[0].clientY : e.changedTouches[0].clientY) : e.clientY;
                
                // 3. THE FIX: Calculate the scaling factor
                // (Internal Canvas Size / Visual CSS Size)
                const scaleX = canvas.width / rect.width;
                const scaleY = canvas.height / rect.height;

                // 4. Return the corrected coordinates
                return { 
                    x: (clientX - rect.left) * scaleX, 
                    y: (clientY - rect.top) * scaleY 
                };
            };

            const onStart = (e) => {
                const { x, y } = getPos(e);
                
                // Hit Radius needs to be scaled too if the image is huge
                // We use a base radius of 40, adjusted by the scale
                const rect = canvas.getBoundingClientRect();
                const scaleX = canvas.width / rect.width;
                const HIT_RADIUS = 50 * scaleX; 

                let minDistance = 9999;
                let foundIndex = -1;

                cropPoints.forEach((p, i) => {
                    const dist = Math.hypot(p.x - x, p.y - y);
                    if (dist < HIT_RADIUS && dist < minDistance) {
                        minDistance = dist;
                        foundIndex = i;
                    }
                });
                
                activePointIndex = foundIndex;
                
                if (activePointIndex !== -1) {
                    // Important: Stop browser scrolling while dragging a point
                    if(e.cancelable) e.preventDefault(); 
                    renderCropUI();
                }
            };

            const onMove = (e) => {
                if (activePointIndex === -1) return;
                
                if(e.cancelable) e.preventDefault();
                
                const { x, y } = getPos(e);
                
                // Keep point inside canvas bounds
                const padding = 10;
                cropPoints[activePointIndex].x = Math.max(padding, Math.min(cropCanvas.width - padding, x));
                cropPoints[activePointIndex].y = Math.max(padding, Math.min(cropCanvas.height - padding, y));
                
                renderCropUI();
            };

            const onEnd = (e) => { 
                if (activePointIndex !== -1 && e.cancelable) {
                    e.preventDefault();
                }
                activePointIndex = -1; 
                renderCropUI(); 
            };

            // Use { passive: false } to allow us to stop scrolling
            canvas.addEventListener('touchstart', onStart, { passive: false });
            canvas.addEventListener('touchmove', onMove, { passive: false });
            canvas.addEventListener('touchend', onEnd, { passive: false });
            
            canvas.addEventListener('mousedown', onStart);
            canvas.addEventListener('mousemove', onMove);
            canvas.addEventListener('mouseup', onEnd);
        }
        
        function triggerDocUpload() { document.getElementById('doc-upload-input').click(); }
        function handleDocUpload(input) {
            editingDocId = null;
            if (input.files && input.files[0]) {
                const file = input.files[0];
                if (file.type === 'application/pdf') {
                    processPdfFile(file);
                    input.value = '';
                    return;
                }
                if (!file.type.startsWith('image/')) { 
                    alert("âš ï¸ Restricted Format\n\nOnly Images and PDFs are allowed."); 
                    input.value = ''; 
                    return; 
                }
                isPdfBatch = false; 
                const reader = new FileReader();
                reader.onload = function(e) { closeScanner(); openEditor(e.target.result); }
                reader.readAsDataURL(file);
            }
            input.value = ''; 
        }

        function triggerStampCamera() {
            isStampMode = true;       // Tell the app we are making a stamp
            captureSource = 'camera'; // Remember source for "Retake" button
            
            // Hide Editor temporarily so we can see the camera
            document.getElementById('view-editor').classList.add('hidden');
            openScanner(); 
        }
                
        function triggerStampInput() { document.getElementById('stamp-input').click(); }
        function processStampUpload(input) {
            if (input.files && input.files[0]) {
                const reader = new FileReader();
                reader.onload = function(e) {
                    isStampMode = true; 
                    captureSource = 'upload'; // <--- Set Source
                    openCropView(e.target.result, null); 
                    input.value = ''; 
                };
                reader.readAsDataURL(input.files[0]);
            }
        }

         async function applyCrop() {
            const view = document.getElementById('view-crop');
            const btn = view.querySelector('button[onclick="applyCrop()"]');
            const originalBtnText = btn.innerHTML;
            btn.innerHTML = '<div class="loader w-4 h-4 border-t-emerald-400"></div>';
            
            await new Promise(r => setTimeout(r, 50));

            try {
                if (typeof cv === 'undefined' || !cv.Mat) throw new Error("OpenCV not ready.");

                const img = new Image();
                img.src = originalCaptureSrc;
                await new Promise(r => img.onload = r);

                const tempCanvas = document.createElement('canvas');
                tempCanvas.width = img.width;
                tempCanvas.height = img.height;
                const tempCtx = tempCanvas.getContext('2d');
                tempCtx.drawImage(img, 0, 0);
                
                let src = cv.imread(tempCanvas);
                let warped = new cv.Mat();
                
                // --- 1. HANDLE PADDING OFFSET (For Stamps) ---
                let padX = 0;
                let padY = 0;
                
                // If we are in Stamp Mode, we must account for the 40px visual padding
                // we added in openCropView.
                if (isStampMode) {
                    // Calculate internal canvas pixels per CSS pixel
                    const ratioX = cropCanvas.width / cropCanvas.clientWidth;
                    const ratioY = cropCanvas.height / cropCanvas.clientHeight;
                    padX = 40 * ratioX;
                    padY = 40 * ratioY;
                }

                // Calculate the "Effective" size of the image on the canvas (excluding padding)
                const effectiveCanvasW = cropCanvas.width - (padX * 2);
                const effectiveCanvasH = cropCanvas.height - (padY * 2);

                // Update Scaling Factor
                // Scale = Real Image Size / Effective Canvas Size
                const scaleX = img.width / effectiveCanvasW;
                const scaleY = img.height / effectiveCanvasH;
                
                // --- 2. GEOMETRIC SORTING (Fixes "Wonky" Crops) ---
                const rawPoints = cropPoints.map(p => ({ x: p.x, y: p.y }));
                
                // Sort by Y to separate Top/Bottom rows
                rawPoints.sort((a, b) => a.y - b.y);
                const topRow = rawPoints.slice(0, 2).sort((a, b) => a.x - b.x);
                const bottomRow = rawPoints.slice(2, 4).sort((a, b) => a.x - b.x);
                
                const sortedPoints = [ topRow[0], topRow[1], bottomRow[1], bottomRow[0] ];

                // --- 3. CREATE SOURCE MATRIX (With Padding Adjustment) ---
                // We subtract the padding (padX/padY) from the point coordinates before scaling
                // to map them correctly to the raw image.
                let srcTri = cv.matFromArray(4, 1, cv.CV_32FC2, [
                    (sortedPoints[0].x - padX) * scaleX, (sortedPoints[0].y - padY) * scaleY, // TL
                    (sortedPoints[1].x - padX) * scaleX, (sortedPoints[1].y - padY) * scaleY, // TR
                    (sortedPoints[2].x - padX) * scaleX, (sortedPoints[2].y - padY) * scaleY, // BR
                    (sortedPoints[3].x - padX) * scaleX, (sortedPoints[3].y - padY) * scaleY  // BL
                ]);

                // --- 4. CALCULATE DESTINATION SIZE ---
                // Calculate real distances using the adjusted coordinates
                const p0x = (sortedPoints[0].x - padX) * scaleX; const p0y = (sortedPoints[0].y - padY) * scaleY;
                const p1x = (sortedPoints[1].x - padX) * scaleX; const p1y = (sortedPoints[1].y - padY) * scaleY;
                const p2x = (sortedPoints[2].x - padX) * scaleX; const p2y = (sortedPoints[2].y - padY) * scaleY;
                const p3x = (sortedPoints[3].x - padX) * scaleX; const p3y = (sortedPoints[3].y - padY) * scaleY;

                const w1 = Math.hypot(p1x - p0x, p1y - p0y);
                const w2 = Math.hypot(p2x - p3x, p2y - p3y);
                const maxWidth = Math.max(w1, w2);

                const h1 = Math.hypot(p0x - p3x, p0y - p3y);
                const h2 = Math.hypot(p1x - p2x, p1y - p2y);
                const maxHeight = Math.max(h1, h2);

                let dstTri = cv.matFromArray(4, 1, cv.CV_32FC2, [
                    0, 0, maxWidth, 0, maxWidth, maxHeight, 0, maxHeight
                ]);

                // Warp
                let M = cv.getPerspectiveTransform(srcTri, dstTri);
                cv.warpPerspective(src, warped, M, new cv.Size(maxWidth, maxHeight));

                // --- 5. ENHANCEMENT (CamScanner Shadow Removal) ---
                let finalMat = warped;
                
                // Skip shadow removal for Stamps (we usually want the ink as-is)
                if (!isStampMode) {
                    try {
                        if (cv.COLOR_RGBA2RGB) {
                            let rgb = new cv.Mat();
                            cv.cvtColor(warped, rgb, cv.COLOR_RGBA2RGB);
                            let lab = new cv.Mat();
                            cv.cvtColor(rgb, lab, cv.COLOR_RGB2Lab);
                            let planes = new cv.MatVector();
                            cv.split(lab, planes);
                            let L = planes.get(0);
                            
                            // Estimate Background
                            let bg = new cv.Mat();
                            let kernel = cv.Mat.ones(40, 40, cv.CV_8U);
                            cv.dilate(L, bg, kernel);
                            cv.medianBlur(bg, bg, 21);
                            
                            // Divide (Flat Field Correction)
                            let L_f = new cv.Mat(); L.convertTo(L_f, cv.CV_32F);
                            let bg_f = new cv.Mat(); bg.convertTo(bg_f, cv.CV_32F);
                            let result_f = new cv.Mat();
                            cv.divide(L_f, bg_f, result_f, 255.0);
                            
                            let flat_L = new cv.Mat();
                            result_f.convertTo(flat_L, cv.CV_8U);
                            
                            // CLAHE
                            let clahe = new cv.createCLAHE(2.0, new cv.Size(8, 8));
                            clahe.apply(flat_L, flat_L);
                            
                            // Merge
                            planes.set(0, flat_L);
                            cv.merge(planes, lab);
                            let enhanced = new cv.Mat();
                            cv.cvtColor(lab, enhanced, cv.COLOR_Lab2RGB);
                            finalMat = enhanced;
                            
                            rgb.delete(); lab.delete(); planes.delete(); L.delete(); bg.delete(); 
                            kernel.delete(); L_f.delete(); bg_f.delete(); result_f.delete(); flat_L.delete(); clahe.delete();
                        }
                    } catch (e) { console.warn("Shadow removal skipped:", e); }
                }

                // Output
                cv.imshow('processing-canvas', finalMat); 
                const outputMime = isStampMode ? 'image/png' : 'image/jpeg';
                const dataUrl = document.getElementById('processing-canvas').toDataURL(outputMime, 0.95);

                // Cleanup
                src.delete(); srcTri.delete(); dstTri.delete(); M.delete(); 
                warped.delete(); if(finalMat !== warped) finalMat.delete();

                // Finish
                view.classList.add('hidden');
                btn.innerHTML = originalBtnText;

                if (isStampMode) {
                    isStampMode = false;
                    document.getElementById('view-editor').classList.remove('hidden');
                    addStampImageToCanvas(dataUrl);
                } else {
                    openEditor(dataUrl);
                }

            } catch (err) {
                console.error("Apply Crop Error:", err);
                alert("Error: " + err.message);
                view.classList.add('hidden');
                btn.innerHTML = originalBtnText;
            }
        }
        
        function toggleStampMenu() {
            const menu = document.getElementById('stamp-options-menu');
            menu.classList.toggle('hidden');
        }

        document.addEventListener('click', function(e) {
            const menu = document.getElementById('stamp-options-menu');
            const btn = e.target.closest('button[onclick="toggleStampMenu()"]');
            const insideMenu = e.target.closest('#stamp-options-menu');
            
            if (!btn && !insideMenu && !menu.classList.contains('hidden')) {
                menu.classList.add('hidden');
            }
        });

        async function handlePasteButton() {
            try {
                const clipboardItems = await navigator.clipboard.read();
                for (const item of clipboardItems) {
                    if (item.types.some(type => type.startsWith('image/'))) {
                        const blob = await item.getType(item.types.find(type => type.startsWith('image/')));
                        const reader = new FileReader();
                        reader.onload = (e) => { 
                            isStampMode = true;
                            captureSource = 'paste'; // <--- Set Source
                            // Hide editor briefly to transition to cropper
                            document.getElementById('view-editor').classList.add('hidden');
                            openCropView(e.target.result, null); 
                        };
                        reader.readAsDataURL(blob);
                        return;
                    }
                }
                alert("No image found in clipboard.");
            } catch (err) {
                console.warn("Clipboard error:", err);
                alert("Paste failed. Please use Ctrl+V.");
            }
        }
        
       function addStampImageToCanvas(dataUrl) {
            if (!fabricCanvas) return;
            
            // 1. Resize Image OFF-SCREEN first
            const imgObj = new Image();
            imgObj.src = dataUrl;
            
            imgObj.onload = function() {
                // Resize logic: Max width 500px
                const MAX_W = 500;
                let w = imgObj.width;
                let h = imgObj.height;
                
                if (w > MAX_W) {
                    h = Math.round(h * (MAX_W / w));
                    w = MAX_W;
                }

                const canvas = document.createElement('canvas');
                canvas.width = w;
                canvas.height = h;
                const ctx = canvas.getContext('2d');
                ctx.drawImage(imgObj, 0, 0, w, h);
                
                // Get optimized (small) image data
                const optimizedUrl = canvas.toDataURL('image/png');

                // 2. Add to Fabric Canvas
                fabric.Image.fromURL(optimizedUrl, function(img) {
                    const targetScale = (fabricCanvas.width * 0.4) / img.width;

                    img.set({
                        left: fabricCanvas.width / 2,
                        top: fabricCanvas.height / 2,
                        originX: 'center',
                        originY: 'center',
                        scaleX: targetScale,
                        scaleY: targetScale,
                        cornerColor: '#10b981', 
                        cornerStyle: 'circle',
                        borderColor: '#10b981',
                        transparentCorners: false,
                        
                        // IMPORTANT: Save the SMALL optimized URL as rawSrc
                        isStamp: true,      
                        rawSrc: optimizedUrl 
                    });

                    fabricCanvas.add(img);
                    fabricCanvas.setActiveObject(img);
                    updateStampThreshold(150); // Initial background removal
                });
            };
        }
        function processAndAddStamp(rawImgSrc) {
            addStampImageToCanvas(rawImgSrc);
        }

        function initFabricListeners() {
            if (!fabricCanvas) return;

            const slider = document.getElementById('stamp-slider-container');

            // --- REUSABLE HELPER: Decide Position (Top vs Bottom) ---
            const updateSliderPosition = (obj) => {
                if (!slider || !obj) return;
                
                const canvasHeight = fabricCanvas.getHeight();
                const objBottomEdge = obj.top + (obj.getScaledHeight() / 2);
                const threshold = canvasHeight * 0.65; // Bottom 35% of screen

                if (objBottomEdge > threshold) {
                    // Stamp is low -> Move slider to TOP
                    slider.classList.remove('bottom-36');
                    slider.classList.add('top-24');
                } else {
                    // Stamp is high -> Move slider to BOTTOM
                    slider.classList.remove('top-24');
                    slider.classList.add('bottom-36');
                }
            };

            // 1. Selection Event (Show Slider)
            const handleSelection = (e) => {
                const activeObj = e.selected ? e.selected[0] : e.target;
                
                if (activeObj && activeObj.type === 'image' && activeObj !== fabricCanvas.backgroundImage) {
                    // A. Check position FIRST (Dodge immediately if needed)
                    updateSliderPosition(activeObj);
                    
                    // B. Then show the slider
                    if (typeof showStampSettings === 'function') {
                        showStampSettings(activeObj);
                    } else {
                        if (slider) slider.classList.remove('hidden');
                    }
                }
            };

            fabricCanvas.on('selection:created', handleSelection);
            fabricCanvas.on('selection:updated', handleSelection);

            // 2. Moving Event (Continuous Dodge)
            fabricCanvas.on('object:moving', (e) => {
                if (slider && !slider.classList.contains('hidden')) {
                    updateSliderPosition(e.target);
                }
            });

            // 3. Deselection (Hide & Reset)
            fabricCanvas.on('selection:cleared', () => {
                if (typeof hideStampSettings === 'function') {
                    hideStampSettings();
                } else {
                    if (slider) {
                        slider.classList.add('hidden');
                        // Reset to default for next time
                        slider.classList.remove('top-24');
                        slider.classList.add('bottom-36');
                    }
                }
            });
        }
        
        function checkSelection(obj) {
            if (obj && obj.isStamp) {
                document.getElementById('stamp-slider-container').classList.remove('hidden');
            } else {
                hideStampSlider();
            }
        }

        

        function hideStampSlider() {
            document.getElementById('stamp-slider-container').classList.add('hidden');
        }

        function deleteSelectedStamp() {
            if (!fabricCanvas) return;

            const activeObj = fabricCanvas.getActiveObject();
            
            if (activeObj && activeObj.type === 'image') {
                // 1. Remove from Canvas
                fabricCanvas.remove(activeObj);
                fabricCanvas.discardActiveObject(); // Clear selection
                fabricCanvas.requestRenderAll();    // Refresh view
                
                // 2. Hide the Settings Panel immediately
                const slider = document.getElementById('stamp-slider-container');
                if (slider) {
                    slider.classList.add('hidden');
                    // Reset position
                    slider.classList.remove('top-24');
                    slider.classList.add('bottom-36');
                }
            }
        }

        let isProcessingSlider = false;

        function updateStampThreshold(thresholdVal) {
            if (!fabricCanvas) return;
            if (isProcessingSlider) return; // Drop frame if busy

            const activeObj = fabricCanvas.getActiveObject();
            if (!activeObj || !activeObj.isStamp || !activeObj.rawSrc) return;

            isProcessingSlider = true;
            const threshold = parseInt(thresholdVal);

            // Use AnimationFrame for smooth UI
            requestAnimationFrame(() => {
                const tempImg = new Image();
                tempImg.src = activeObj.rawSrc; // This is now the small image!
                
                tempImg.onload = function() {
                    const canvas = document.createElement('canvas');
                    const ctx = canvas.getContext('2d');
                    canvas.width = tempImg.width;
                    canvas.height = tempImg.height;
                    
                    ctx.drawImage(tempImg, 0, 0);
                    
                    const imgData = ctx.getImageData(0, 0, canvas.width, canvas.height);
                    const data = imgData.data;

                    // Fast loop (small array)
                    for (let i = 0; i < data.length; i += 4) {
                        const r = data[i];
                        const g = data[i + 1];
                        const b = data[i + 2];
                        // Simple lightness check
                        if (((r + g + b) / 3) > threshold) {
                            data[i + 3] = 0; // Transparent
                        } 
                    }

                    ctx.putImageData(imgData, 0, 0);
                    
                    activeObj.setSrc(canvas.toDataURL(), function() {
                        fabricCanvas.renderAll();
                        isProcessingSlider = false; // Unlock
                    });
                };
            });
        }

        function addTextToCanvas() {
            if (!fabricCanvas) return;
            
            const text = new fabric.IText('Tap to Edit', {
                left: fabricCanvas.width / 2,
                top: fabricCanvas.height / 2,
                fontFamily: 'Calibri',
                fill: '#000000', 
                fontSize: 24,
                fontWeight: 'bold',
                originX: 'center',
                originY: 'center',
                cornerColor: 'blue',
                cornerStyle: 'circle',
                borderColor: 'blue',
                transparentCorners: false
            });

            fabricCanvas.add(text);
            fabricCanvas.setActiveObject(text); 
            fabricCanvas.renderAll();
        }
        
        function cancelEdit() {
            // Hide the Editor View
            document.getElementById('view-editor').classList.add('hidden');
            
            // --- FIX: Force Hide Stamp Settings ---
            const slider = document.getElementById('stamp-slider-container');
            if (slider) {
                slider.classList.add('hidden');
                // Reset position to default (bottom) so it doesn't get stuck at the top
                slider.classList.remove('top-24');
                slider.classList.add('bottom-36');
            }

            // Cleanup Canvas
            if (fabricCanvas) {
                try { fabricCanvas.dispose(); } catch (e) {}
                fabricCanvas = null;
            }

            // Reset File Inputs (so you can upload the same file again if needed)
            document.getElementById('doc-upload-input').value = '';
            document.getElementById('stamp-input').value = '';
            
            // Reset Flags
            editingDocId = null;
            isStampMode = false;
        }

        async function handlePasteClick() {
            editingDocId = null;
            try {
                const items = await navigator.clipboard.read();
                for (const item of items) {
                    if (item.types.includes('image/png') || item.types.includes('image/jpeg')) {
                        const blob = await item.getType(item.types.find(t => t.startsWith('image/')));
                        const reader = new FileReader();
                        reader.onload = (e) => { closeAddMenu(); openEditor(e.target.result); };
                        reader.readAsDataURL(blob);
                        return;
                    }
                }
                alert("No image found in clipboard.");
            } catch (err) { console.warn(err); alert("Use Ctrl+V to paste."); }
        }

        function setupPasteListener() {
            document.addEventListener('paste', function(e) {
                if (!currentJobId && document.getElementById('view-editor').classList.contains('hidden')) return;

                const items = (e.clipboardData || e.originalEvent.clipboardData).items;
                let blob = null;
                for (let i = 0; i < items.length; i++) {
                    if (items[i].type.indexOf("image") === 0) { blob = items[i].getAsFile(); break; }
                }

                if (blob !== null) {
                    e.preventDefault();
                    const reader = new FileReader();
                    
                    reader.onload = function(event) { 
                        const editorView = document.getElementById('view-editor');
                        
                        if (!editorView.classList.contains('hidden')) {
                            processAndAddStamp(event.target.result);
                        } else {
                            closeAddMenu(); 
                            closeScanner(); 
                            openEditor(event.target.result); 
                        }
                    };
                    reader.readAsDataURL(blob);
                }
            });
        }

        // Store the scale factor globally so we can reverse it later
        let editorScaleFactor = 1; 
        
        function openEditor(imageInput) {
            document.getElementById('stamp-slider-container').classList.add('hidden');
            document.getElementById('view-editor').classList.remove('hidden');
            
            const container = document.getElementById('view-editor').querySelector('.flex-1');
            const canvasWrapper = document.getElementById('canvas-wrapper');
            
            // Give some breathing room
            const maxWidth = container.clientWidth - 40; 
            const maxHeight = container.clientHeight - 80;
            
            // Reset Canvas
            if (fabricCanvas) { try { fabricCanvas.dispose(); } catch (e) {} fabricCanvas = null; }
            canvasWrapper.innerHTML = '<canvas id="fabric-canvas"></canvas>';
            
            fabricCanvas = new fabric.Canvas('fabric-canvas');
           
            initFabricZoom();
            
            let dataUrl = (typeof imageInput === 'string') ? imageInput : imageInput.toDataURL();
            
            fabric.Image.fromURL(dataUrl, function(img) {
                // --- SMART SCALING LOGIC ---
                // 1. Calculate how small we made it for the screen
                const scale = Math.min(maxWidth / img.width, maxHeight / img.height);
                
                // 2. Save this factor! We need 1/scale to restore it later.
                editorScaleFactor = scale; 
        
                fabricCanvas.setWidth(img.width * scale); 
                fabricCanvas.setHeight(img.height * scale);
                
                img.set({ 
                    originX: 'center', 
                    originY: 'center', 
                    left: fabricCanvas.width / 2, 
                    top: fabricCanvas.height / 2, 
                    scaleX: scale, 
                    scaleY: scale, 
                    selectable: false, 
                    evented: false 
                });
                
                fabricCanvas.add(img); 
                fabricCanvas.backgroundImage = img; 
                fabricCanvas.renderAll();
                initFabricListeners();
            });
        }
        
        function rotateDoc(direction) {
            if (!fabricCanvas || !fabricCanvas.backgroundImage) return;
            const img = fabricCanvas.backgroundImage;
            const angle = (direction === 'left' ? -90 : 90);
            img.rotate((img.angle || 0) + angle % 360);
            const container = document.getElementById('view-editor').querySelector('.flex-1');
            const maxWidth = container.clientWidth - 40; const maxHeight = container.clientHeight - 40;
            const isVertical = img.angle % 180 !== 0;
            const effectiveW = isVertical ? img.height : img.width;
            const effectiveH = isVertical ? img.width : img.height;
            const scale = Math.min(maxWidth / effectiveW, maxHeight / effectiveH);
            editorScaleFactor = scale;
            fabricCanvas.setWidth(effectiveW * scale); fabricCanvas.setHeight(effectiveH * scale);
            img.set({ left: fabricCanvas.width / 2, top: fabricCanvas.height / 2, scaleX: scale, scaleY: scale });
            img.setCoords(); fabricCanvas.renderAll();
        }
        
        function openAddMenu() { document.getElementById('add-menu-modal').classList.remove('hidden'); document.getElementById('add-menu-modal').classList.add('flex'); }
        function closeAddMenu() { document.getElementById('add-menu-modal').classList.add('hidden'); document.getElementById('add-menu-modal').classList.remove('flex'); }
        function openScannerFromMenu() { closeAddMenu(); openScanner(); }
        function triggerDocUploadFromMenu() { closeAddMenu(); triggerDocUpload(); }
        
        // --- SAVE/OCR ---
       function openSaveModal() {
            const modal = document.getElementById('save-modal');
            const select = document.getElementById('doc-type-select');
            
            // Elements
            const reqCheckbox = document.getElementById('require-sign-checkbox');
            const signContainer = document.getElementById('approver-sign-container');
            const signCheckbox = document.getElementById('mark-signed-checkbox');

            // 1. Reset States
            if (reqCheckbox) reqCheckbox.checked = false;
            if (signCheckbox) signCheckbox.checked = false;

            // 2. Approver Logic: Show/Hide the "Mark as Approved" box
            if (userIsApprover) {
                signContainer.classList.remove('hidden');
            } else {
                signContainer.classList.add('hidden');
            }

            // 3. Auto-fill Data (If Editing)
            if (editingDocId && currentJobId) {
                const job = jobs.find(j => j.id === currentJobId);
                if (job) {
                    const doc = job.documents.find(d => d.id === editingDocId);
                    if (doc) {
                        if (doc.docCategory) select.value = doc.docCategory;
                        
                        // Restore "Require Approval"
                        if (doc.requiresSignature) reqCheckbox.checked = true;
                        
                        // Restore "Is Signed" (Only if Approver)
                        if (userIsApprover && doc.isSigned) signCheckbox.checked = true;
                    }
                }
            } else {
                // Default category
                select.value = "Delivery Order"; 
            }
            
            // Show Modal
            modal.classList.remove('hidden');
            document.getElementById('ocr-loading').classList.add('hidden');
            document.getElementById('btn-cancel-save').classList.remove('hidden');
            document.getElementById('btn-confirm-save').classList.remove('hidden');
        }
        
        function closeSaveModal() { document.getElementById('save-modal').classList.add('hidden'); }

        function parseSmartMetadata(text) {
            const result = { id: null, date: null, amount: null };
            const idMatch = text.match(/(?:no\.|id|#|ref|invoice|order|number)[\s.:]*([a-z0-9\-\/]{3,})/i);
            if (idMatch) result.id = idMatch[1].toUpperCase();
            const dateMatch = text.match(/(\d{1,2}[-/\.]\d{1,2}[-/\.]\d{2,4})/);
            if (dateMatch) result.date = dateMatch[1];
            const amountMatch = text.match(/(?:total|amount|grand total|balance)[\s.:$rm]*([\d,]+\.\d{2})/i);
            if (amountMatch) result.amount = amountMatch[1];
            return result;
        }

        async function confirmSave() {
            // 1. GET UI ELEMENTS
            const categorySelect = document.getElementById('doc-type-select');
            const category = categorySelect.value;
            const saveBtn = document.getElementById('btn-confirm-save');
            
            const reqCheckbox = document.getElementById('require-sign-checkbox');
            const signCheckbox = document.getElementById('mark-signed-checkbox');
            
            // 2. READ SETTINGS & APPROVER LOGIC
            let requiresSignature = reqCheckbox.checked;
            let isSigned = false;
            let currentApproverName = null;
            let currentApproverUid = null;

            // If user is Approver AND checked the "Mark as Approved" box
            if (userIsApprover && signCheckbox && signCheckbox.checked) {
                isSigned = true;
                requiresSignature = true; // Force this true so the Green Badge appears
                currentApproverName = (currentUser.email.split('@')[0]);
                currentApproverUid = currentUser.uid;
            } 
            // If editing an existing doc that was ALREADY signed, preserve it
            else if (editingDocId && currentJobId) {
                 const job = jobs.find(j => j.id === currentJobId);
                 if (job) {
                    const doc = job.documents.find(d => d.id === editingDocId);
                    if (doc && doc.isSigned) {
                        isSigned = true;
                        currentApproverName = doc.approverName;
                        currentApproverUid = doc.approverUid;
                    }
                 }
            }

            // --- PRESERVE GROUP LOGIC ---
            let existingGroupId = null;
            let existingPageIndex = 0;

            if (editingDocId && currentJobId) {
                const job = jobs.find(j => j.id === currentJobId);
                if (job) {
                    const doc = job.documents.find(d => d.id === editingDocId);
                    if (doc) {
                        existingGroupId = doc.groupId || null;
                        existingPageIndex = doc.pageIndex || 0;
                    }
                }
            }

            const originalBtnText = saveBtn.innerHTML;
            saveBtn.innerHTML = 'Saving...'; 
            saveBtn.disabled = true;

            await new Promise(r => setTimeout(r, 50));

            try {
                // --- PERFORMANCE OPTIMIZATION ---
                const targetSize = 1920; 
                const currentLongestSide = Math.max(fabricCanvas.width, fabricCanvas.height);
                let finalMultiplier = targetSize / currentLongestSide;

                if (editorScaleFactor > 0) {
                     const originalResMultiplier = 1 / editorScaleFactor;
                     finalMultiplier = Math.min(finalMultiplier, originalResMultiplier);
                }

                const currentDataURL = fabricCanvas.toDataURL({ 
                    format: 'webp', 
                    quality: 0.85, 
                    multiplier: finalMultiplier 
                });
                
                let finalSaveList = [];
                if (isPdfBatch) {
                    finalSaveList = [currentDataURL, ...batchQueue];
                } else {
                    finalSaveList = [...batchQueue, currentDataURL];
                }
                
                const totalPages = finalSaveList.length;
                const baseId = Math.random().toString(36).substr(2, 4).toUpperCase();
                
                let groupId = existingGroupId;
                if (!groupId && totalPages > 1) {
                    groupId = 'grp_' + Date.now();
                }

                // 3. SAVE LOOP
                for (let i = 0; i < totalPages; i++) {
                    const dataUrl = finalSaveList[i];
                    let pageSuffix = totalPages > 1 ? ` (Page ${i + 1})` : "";
                    
                    let idToOverwrite = null;
                    let currentIndex = i;

                    if (i === 0 && editingDocId) {
                        idToOverwrite = editingDocId;
                        if (!isPdfBatch) currentIndex = existingPageIndex;
                    }

                    // Pass the extra signature data to the helper
                    await saveSingleDocument(
                        dataUrl, category, isSigned, baseId, pageSuffix, 
                        idToOverwrite, requiresSignature, 
                        groupId, currentIndex,
                        currentApproverName, currentApproverUid // <--- Pass these new values
                    );
                }

                isPdfBatch = false;
                batchQueue = [];
                const title = document.querySelector('#add-menu-modal h3');
                if(title) title.textContent = 'Add Document';

                closeSaveModal(); 
                cancelEdit(); 
                editingDocId = null;

                if (totalPages > 1) alert(`âœ… Saved ${totalPages} pages.`);

            } catch (err) {
                console.error("Save Error", err);
                alert("Error saving document.");
            } finally {
                saveBtn.innerHTML = originalBtnText;
                saveBtn.disabled = false;
            }
        }
        
        // UPDATED SIGNATURE: Added groupId and pageIndex
        // UPDATED SIGNATURE: Added approver details
        async function saveSingleDocument(dataURL, category, isSigned, baseId, nameSuffix, overwriteId = null, requiresSignature = false, groupId = null, pageIndex = 0, approverName = null, approverUid = null) {
            let finalDocId, finalDocName;
        
            if (overwriteId) {
                finalDocId = overwriteId;
                const job = jobs.find(j => j.id === currentJobId);
                const existingDoc = job ? job.documents.find(d => d.id === overwriteId) : null;
                if (existingDoc && existingDoc.docCategory === category) {
                     finalDocName = existingDoc.name;
                } else {
                     finalDocName = `${category}${nameSuffix}.webp`;
                }
            } else {
                finalDocId = 'doc_' + Date.now() + '_' + Math.floor(Math.random() * 1000);
                let candidateName = `${category}${nameSuffix}.webp`;
                const job = jobs.find(j => j.id === currentJobId);
                if (job && job.documents) {
                    let counter = 1;
                    while (job.documents.some(d => d.name === candidateName)) {
                        counter++;
                        candidateName = `${category}${nameSuffix} (${counter}).webp`;
                    }
                }
                finalDocName = candidateName;
            }

            const blob = await (await fetch(dataURL)).blob();
            const arrayBuffer = await blob.arrayBuffer();
            const uint8Array = new Uint8Array(arrayBuffer);
            const firestoreBlob = firebase.firestore.Blob.fromUint8Array(uint8Array);
            const sizeMb = (blob.size / (1024*1024)).toFixed(2);
            const sizeStr = sizeMb < 1 ? (blob.size/1024).toFixed(0) + 'KB' : sizeMb + 'MB';

            const newDoc = {
                id: finalDocId, 
                name: finalDocName,
                docCategory: category,
                type: 'scan',
                size: sizeStr,
                date: new Date().toISOString(),
                ocrText: "", 
                smartData: {}, 
                isSigned: isSigned,
                requiresSignature: requiresSignature, 
                approverName: approverName, // <--- Using the passed argument
                approverUid: approverUid,   // <--- Using the passed argument
                groupId: groupId, 
                pageIndex: pageIndex 
            };

            if (db) {
                const cloudDocMetadata = { ...newDoc };
                delete cloudDocMetadata.src; 
                cloudDocMetadata.hasBinary = true; 
                
                const scanData = { image_blob: firestoreBlob, timestamp: Date.now(), name: finalDocName };
                await db.collection('jobs').doc(currentJobId).collection('scans').doc(finalDocId).set(scanData);

                if (overwriteId) {
                    const jobRef = db.collection('jobs').doc(currentJobId);
                    const jobSnap = await jobRef.get();
                    let currentDocs = jobSnap.data().documents || [];
                    
                    const idx = currentDocs.findIndex(d => d.id === overwriteId);
                    if (idx !== -1) {
                        // If we are passing specific approver info (because we just signed it), use it.
                        // Otherwise, if we are just editing content, PRESERVE existing approval.
                        if (!approverUid && currentDocs[idx].approverUid) {
                            cloudDocMetadata.approverName = currentDocs[idx].approverName;
                            cloudDocMetadata.approverUid = currentDocs[idx].approverUid;
                            cloudDocMetadata.isSigned = true;
                        }

                        if (currentDocs[idx].groupId && !groupId) {
                            cloudDocMetadata.groupId = currentDocs[idx].groupId;
                            cloudDocMetadata.pageIndex = currentDocs[idx].pageIndex;
                        }
                        
                        currentDocs[idx] = cloudDocMetadata; 
                        await jobRef.update({ documents: currentDocs });
                    }
                } else {
                    await db.collection('jobs').doc(currentJobId).update({
                        documents: firebase.firestore.FieldValue.arrayUnion(cloudDocMetadata)
                    });
                }
            } 
            
            const job = jobs.find(j => j.id === currentJobId);
            newDoc.src = dataURL; 
            
            if (overwriteId) {
                const idx = job.documents.findIndex(d => d.id === overwriteId);
                if (idx !== -1) job.documents[idx] = newDoc;
            } else {
                const alreadyExists = job.documents.some(d => d.id === newDoc.id);
                if (!alreadyExists) job.documents.push(newDoc);
            }
            
            renderDocumentList(job);
        }

        // Global variable to hold the list of jobs pending archive
        let pendingArchiveJobs = [];
        
        async function archiveClosedJobs() {
            // 1. Admin Check
            if (typeof userRole === 'undefined' || userRole !== 'admin') {
                alert("â›” Access Denied\n\nOnly Administrators can archive jobs.");
                return;
            }
        
            // 2. Find Candidates
            pendingArchiveJobs = jobs.filter(j => getJobStatus(j) === 'Completed' && !j.isArchived);
            
            if (pendingArchiveJobs.length === 0) {
                return alert("No active completed jobs to archive.");
            }
        
            // 3. UI Setup
            const modal = document.getElementById('archive-confirm-modal');
            const countEl = document.getElementById('archive-count');
            const inputEl = document.getElementById('archive-filename-input');
            
            const dateStr = new Date().toISOString().slice(0, 10);
            const defaultName = `DocuFlow_Archive_${dateStr}_(${pendingArchiveJobs.length}jobs).cbor`;
            
            countEl.innerText = pendingArchiveJobs.length;
            inputEl.value = defaultName;
            
            modal.classList.remove('hidden');
        }
        
        // Helper: Convert Blob URL to Raw Binary (Uint8Array)
        const blobUrlToBinary = async (url) => {
            const response = await fetch(url);
            const blob = await response.blob();
            const arrayBuffer = await blob.arrayBuffer();
            return new Uint8Array(arrayBuffer); // <--- Pure Binary Data
        };
        
        async function executeArchive() {
            const modal = document.getElementById('archive-confirm-modal');
            const inputEl = document.getElementById('archive-filename-input');
            const btn = document.getElementById('btn-execute-archive');
            
            let filename = inputEl.value.trim();
            if (!filename) return alert("Please enter a filename.");
            if (!filename.endsWith('.cbor')) filename += '.cbor';
        
            const originalText = btn.innerHTML;
            btn.innerHTML = `<div class="loader w-4 h-4 border-t-white"></div> converting images...`;
            btn.disabled = true;
            document.body.style.cursor = 'wait';
        
            try {
                const fullBackupData = [];
                
                // 1. PREPARE DATA (CONVERT BLOBs TO BINARY)
                for (const job of pendingArchiveJobs) {
                    const jobCopy = JSON.parse(JSON.stringify(job)); 
                    
                    for (const doc of jobCopy.documents) {
                        // Fetch the image (usually returns a blob: url)
                        let imgData = await ensureDocImageLoaded(job, doc);
                        
                        // CRITICAL UPDATE: Convert Blob URL to Uint8Array (Binary)
                        if (imgData && typeof imgData === 'string' && imgData.startsWith('blob:')) {
                            try {
                                imgData = await blobUrlToBinary(imgData);
                            } catch (err) {
                                console.error("Failed to convert blob", err);
                                // Fallback: keep the blob url (though it won't work offline) or null
                            }
                        }
        
                        // imgData is now a Uint8Array (if conversion worked)
                        // CBOR encodes this efficiently as a byte string
                        doc.src = imgData; 
                        delete doc.image_blob; 
                    }
                    fullBackupData.push(jobCopy);
                }
        
                btn.innerHTML = `<div class="loader w-4 h-4 border-t-white"></div> saving file...`;
        
                // 2. DOWNLOAD FILE
                // CBOR.encode handles Uint8Array automatically!
                const archivePayload = { version: 1, timestamp: Date.now(), jobs: fullBackupData };
                const blob = new Blob([CBOR.encode(archivePayload)], { type: 'application/cbor' });
                const url = URL.createObjectURL(blob);
                
                const a = document.createElement('a');
                a.href = url;
                a.download = filename;
                document.body.appendChild(a);
                a.click();
                document.body.removeChild(a);
                
                // Wait to ensure download starts
                await new Promise(r => setTimeout(r, 1000));
        
                // 3. WIPE DATABASE
                if (db) {
                    const batch = db.batch();
                    
                    for (const job of pendingArchiveJobs) {
                        const jobRef = db.collection('jobs').doc(job.id);
                        
                        const placeholderDocs = job.documents.map(d => ({
                            id: d.id,
                            name: d.name,
                            docCategory: d.docCategory,
                            date: d.date,
                            size: d.size, 
                            isSigned: d.isSigned,
                            isOffline: true 
                        }));
        
                        batch.update(jobRef, { 
                            isArchived: true,
                            archivedAt: new Date().toISOString(),
                            archiveFilename: filename,
                            documents: placeholderDocs 
                        });
        
                        const scanSnaps = await jobRef.collection('scans').get();
                        scanSnaps.forEach(doc => batch.delete(doc.ref));
                    }
                    
                    await batch.commit();
                    alert(`âœ… Archive Complete!\n\nImages converted and saved to '${filename}'.\nCloud storage cleared.`);
                    modal.classList.add('hidden');
                }
        
            } catch (e) {
                console.error("Archive Error:", e);
                alert("Failed to archive: " + e.message);
            } finally {
                btn.innerHTML = originalText;
                btn.disabled = false;
                document.body.style.cursor = 'default';
                pendingArchiveJobs = [];
            }
        }
        
       function handleArchiveUpload(input) {
            if (!input.files || !input.files[0]) return;
            const file = input.files[0];
            const reader = new FileReader();
            
            // UI Feedback
            document.body.style.cursor = 'wait';
            
            reader.onload = function(e) {
                try {
                    let data;
                    if (file.name.endsWith('.json')) {
                        data = JSON.parse(e.target.result);
                    } else {
                        // Assuming global CBOR object exists
                        data = CBOR.decode(e.target.result);
                    }
                    
                    if (!data || !data.jobs) throw new Error("Invalid file structure");
        
                    console.log(`ðŸ“‚ Loading ${data.jobs.length} jobs from file...`);
        
                    let restoreCount = 0;
                    let jobsUpdated = new Set(); // Track which jobs got updated
                    
                    // --- ROBUST HYDRATION LOOP ---
                    data.jobs.forEach(loadedJob => {
                        // 1. Search in ARCHIVE List (Primary)
                        let targetJob = archivedJobs.find(j => j.id === loadedJob.id);
                        
                        // 2. Search in ACTIVE List (Fallback - just in case)
                        if (!targetJob) {
                            targetJob = jobs.find(j => j.id === loadedJob.id);
                        }
        
                        if (targetJob) {
                            loadedJob.documents.forEach(loadedDoc => {
                                const targetDoc = targetJob.documents.find(d => d.id === loadedDoc.id);
                                
                                // We only restore if we have new data (src) to inject
                                if (targetDoc && loadedDoc.src) {
                                    console.log(`âœ… Restoring: ${targetJob.id} / ${targetDoc.name}`);
                                    
                                    targetDoc.src = loadedDoc.src; // Inject Binary/Base64
                                    targetDoc.isOffline = false;   // CRITICAL: Flip the flag
                                    restoreCount++;
                                    jobsUpdated.add(targetJob.id);
                                }
                            });
                        }
                    });
        
                    console.log(`ðŸ”„ Restored ${restoreCount} images total.`);
        
                    if (restoreCount > 0) {
                        // --- FORCE UI REFRESH ---
                        // If we are currently viewing a job that was just updated, re-render it IMMEDIATELY
                        if (currentJobId && jobsUpdated.has(currentJobId)) {
                            // Find the job object again to be safe
                            const jobToRender = archivedJobs.find(j => j.id === currentJobId) || jobs.find(j => j.id === currentJobId);
                            if (jobToRender) {
                                console.log("ðŸŽ¨ Re-rendering current job UI...");
                                renderDocumentList(jobToRender);
                            }
                        }
                        
                        // If we were waiting for a specific doc (from the "View" prompt), open it now
                        if (viewingDocId) {
                            viewDocument(viewingDocId);
                        }
                        
                        alert(`âœ… Successfully restored ${restoreCount} documents.`);
                    } else {
                        // Fallback: If no matches were found, maybe they are loading a totally different archive?
                        // Switch to Archive View and show what was loaded
                        isViewingArchive = true;
                        archivedJobs = data.jobs; 
                        renderJobs();
                        alert(`Loaded ${data.jobs.length} jobs from archive (View Only).`);
                    }
        
                } catch (err) {
                    console.error("Archive Load Error:", err);
                    alert("Failed to load archive: " + err.message);
                } finally {
                    document.body.style.cursor = 'default';
                    input.value = ''; // Reset input so we can select the same file again if needed
                }
            };
            
            if (file.name.endsWith('.json')) {
                reader.readAsText(file);
            } else {
                reader.readAsArrayBuffer(file);
            }
        }

        function downloadJobBundle() {
            if (!currentJobId) return;
            const sourceList = isViewingArchive ? archivedJobs : jobs;
            const job = sourceList.find(j => j.id === currentJobId);
            if (!job || !job.documents.length) return alert("No documents to download.");

            const { jsPDF } = window.jspdf;
            const doc = new jsPDF();
            
            let y = 10;
            doc.setFontSize(16);
            doc.text(`Job Bundle: ${job.client}`, 10, y);
            y += 10;
            doc.setFontSize(10);
            doc.text(`ID: ${job.id} | Date: ${job.date}`, 10, y);
            y += 10;

            job.documents.forEach((d, index) => {
                doc.text(`${index + 1}. ${d.docCategory} - ${d.name}`, 10, y);
                y += 7;
            });

            doc.save(`${job.client}_Bundle.pdf`);
        }

        // Renamed for clarity (was downloadSinglePDF)
        async function openDownloadModal(docId, isGroup = false) {
            const sourceList = isViewingArchive ? archivedJobs : jobs;
            const job = sourceList.find(j => j.id === currentJobId);
            const doc = job.documents.find(d => d.id === docId);
            if (!doc) return;
        
            pendingDownloadDocId = docId;
            isGroupDownloadAction = isGroup; // <--- Set the flag based on which button was clicked
        
            const modal = document.getElementById('download-modal');
            const img = document.getElementById('download-preview-img');
            const input = document.getElementById('pdf-filename');
            const loader = document.getElementById('preview-loader');
            const title = modal.querySelector('h3'); 
        
            modal.classList.remove('hidden');
            setTimeout(() => modal.classList.remove('opacity-0'), 10);
            
            img.classList.add('opacity-0');
            img.src = '';
            loader.classList.remove('hidden');
            
            // --- SMART NAMING LOGIC ---
            let baseName = doc.name.replace(/\.[^/.]+$/, "");
            
            if (isGroup) {
                // Group Mode: Remove "(Page X)" to get a clean name like "Delivery Order"
                baseName = baseName.replace(/\s*\(Page\s+\d+\).*/i, '');
                title.textContent = `Export Group PDF`;
            } else {
                // Single Mode: Keep the full name like "Delivery Order (Page 2)"
                title.textContent = "Export Single Page";
            }
            
            // Fallback if name is empty
            if (!baseName || baseName.startsWith('scan_')) {
                 const dateStr = new Date().toISOString().slice(0,10);
                 baseName = `${doc.docCategory}_${dateStr}`;
            }
        
            input.value = baseName;
            input.select(); 
        
            // Load Preview (Always shows Page 1 of the selection)
            const imgSrc = await ensureDocImageLoaded(job, doc);
            if(imgSrc) {
                img.src = imgSrc;
            } else {
                alert("Error loading image preview.");
                closeDownloadModal();
            }
        }
        
        function closeDownloadModal() {
            const modal = document.getElementById('download-modal');
            modal.classList.add('opacity-0');
            setTimeout(() => {
                modal.classList.add('hidden');
                document.getElementById('download-preview-img').src = '';
                pendingDownloadDocId = null;
            }, 200);
        }

        async function executePDFDownload() {
            if (!pendingDownloadDocId) return;
        
            const sourceList = isViewingArchive ? archivedJobs : jobs;
            const job = sourceList.find(j => j.id === currentJobId);
            const mainDoc = job.documents.find(d => d.id === pendingDownloadDocId);
            if (!mainDoc) return;
        
            // --- SELECTION LOGIC ---
            let docsToDownload = [mainDoc];
        
            // Only grab siblings if the USER clicked the "Group Export" button
            if (isGroupDownloadAction && mainDoc.groupId) {
                const siblings = job.documents.filter(d => d.groupId === mainDoc.groupId);
                // Sort by pageIndex to ensure PDF is in correct order
                siblings.sort((a, b) => (a.pageIndex || 0) - (b.pageIndex || 0));
                docsToDownload = siblings;
            } 
            // Else: docsToDownload remains just [mainDoc] (Single page export)
        
            const filenameInput = document.getElementById('pdf-filename').value.trim();
            const finalFilename = (filenameInput || "document") + ".pdf";
        
            closeDownloadModal();
            
            // Show loading icon on the main header button (optional UX touch)
            const downloadBtn = document.querySelector('button[onclick="downloadJobBundle()"]');
            if(downloadBtn) downloadBtn.innerHTML = '<div class="loader w-4 h-4"></div>';
        
            try {
                const { jsPDF } = window.jspdf;
                // Initialize PDF (Orientation will be set per page)
                const pdf = new jsPDF({ orientation: 'p', unit: 'mm', format: 'a4' });
                
                for (let i = 0; i < docsToDownload.length; i++) {
                    const doc = docsToDownload[i];
                    const imgSrc = await ensureDocImageLoaded(job, doc);
                    
                    const img = new Image();
                    img.src = imgSrc;
                    await new Promise(r => img.onload = r);
        
                    // Clean data
                    const canvas = document.createElement('canvas');
                    canvas.width = img.width;
                    canvas.height = img.height;
                    const ctx = canvas.getContext('2d');
                    ctx.drawImage(img, 0, 0);
                    const cleanDataURL = canvas.toDataURL('image/jpeg', 0.85);
        
                    const isLandscape = img.width > img.height;
                    
                    // Page Management
                    if (i > 0) {
                        pdf.addPage('a4', isLandscape ? 'l' : 'p');
                    } else {
                        if (isLandscape) pdf.deletePage(1); 
                        if (isLandscape) pdf.addPage('a4', 'l');
                    }
        
                    const pageWidth = pdf.internal.pageSize.getWidth();
                    const pageHeight = pdf.internal.pageSize.getHeight();
                    
                    // Scale to fit page
                    const widthRatio = pageWidth / img.width;
                    const heightRatio = pageHeight / img.height;
                    const ratio = Math.min(widthRatio, heightRatio);
                    
                    const finalW = img.width * ratio;
                    const finalH = img.height * ratio;
                    const x = (pageWidth - finalW) / 2;
                    const y = (pageHeight - finalH) / 2;
        
                    pdf.addImage(cleanDataURL, 'JPEG', x, y, finalW, finalH);
                }
        
                pdf.save(finalFilename);
        
            } catch (err) {
                console.error("PDF Gen Error:", err);
                alert("Failed to generate PDF.");
            } finally {
                if(downloadBtn) downloadBtn.innerHTML = '<i data-lucide="file-stack" class="w-5 h-5"></i>';
                if(typeof lucide !== 'undefined') lucide.createIcons();
            }
        }
        
        window.onload = () => {
            const initUI = setInterval(() => {
                if(typeof lucide !== 'undefined') {
                    lucide.createIcons();
                    
                    // 1. Initialize Backend Connection
                    initFirebase(); 
                    
                    // 2. Setup Paste (Global listener)
                    setupPasteListener();
                    
                    // 3. START AUTH SYSTEM (The new gatekeeper)
                    // This will check if the user is logged in and toggle 
                    // between the Login View and the Main App View.
                    initAuthSystem();
                    
                    clearInterval(initUI);
                }
            }, 100);
        };
        
    </script>
</body>
</html>




